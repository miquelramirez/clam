#!/usr/bin/python
import os
import glob
import SCons.Util
from SCons.Util import CLVar

options = Options('options.cache', ARGUMENTS)
options.Add(PathOption('install_prefix', 'The prefix where the annotator will be installed', ''))
options.Add(PathOption('clam_prefix', 'The prefix where CLAM was installed', ''))
options.Add(PathOption('clam_vmqt4_path', 'The path to the vmqt module', '')) # to be removed
options.Add(BoolOption( 'release', 'Build CLAM Annotator enabling compiler optimizations', 'no') )

def scanFiles(pattern, paths) :
	files = []
	for path in paths :
		files+=glob.glob(path+"/"+pattern)
	return files

def recursiveDirs(root) :
	return filter( (lambda a : a.rfind( "CVS")==-1 ),  [ a[0] for a in os.walk(root)]  )

env = Environment(tools=['default','qt'], options=options)
options.Save('options.cache', env)
Help(options.GenerateHelpText(env))

CLAMInstallDir = env['clam_prefix']
CLAMVmQtPath = env['clam_vmqt4_path']

env['CXXFILESUFFIX'] = '.cxx'
env['QT_MOC'] = 'moc-qt4'
env['QT4_MOC'] = 'moc-qt4'
env['QT4_UIC'] = 'uic-qt4'
env['QT_MOCHPREFIX'] = 'generated/moc_'
env['QT_UISUFFIX'] = '.ui'
env['QT_UICDECLPREFIX'] = 'generated/ui_'
env['QT_UICDECLSUFFIX'] = '.hxx'
env['QT_LIB'] = '' # KLUDGE to avoid linking qt3 library

# TODO: An emmiter is needed in order make the qrc depend on the actual
# files for the resources. If so, single_source is no more convenient
# and the Qrc must be called separatelly for each qrc file.
qrcbuilder = Builder(
	action ='rcc $SOURCE -o $TARGET',
	src_suffix = '.qrc',
	suffix = '.cxx',
	prefix = 'generated/qrc_',
	single_source = True
	)
env.Append( BUILDERS = { 'Qrc': qrcbuilder } )

env['QT_UIC4COM'] = [
	CLVar('$QT4_UIC $QT_UICDECLFLAGS -o ${TARGETS[0]} $SOURCE'),
	]
uic4builder = Builder(
    action='$QT_UIC4COM',
	src_suffix='$QT_UISUFFIX',
	suffix='$QT_UICDECLSUFFIX',
	prefix='$QT_UICDECLPREFIX',
	single_source = True
	)
env.Append( BUILDERS = { 'Uic4': uic4builder } )

pkgconfigLibraries = [
	'clam_core',
	'clam_audioio',
	'clam_processing',
	'QtCore',
	'QtGui',
	'QtOpenGL',
#	'QtSvg',
#	'QtSql',
#	'QtNetwork',
#	'QtTest',
#	'QtXml',
#	'QtSvg',
#	'Qt3Support',
]

sourcePaths = [
	'.',
	'generated',
]
extraPaths = []
extraPaths += recursiveDirs(CLAMVmQtPath+"/plot")
extraPaths += recursiveDirs(CLAMVmQtPath+"/render")
extraPaths += recursiveDirs(CLAMVmQtPath+"/data")
extraPaths += recursiveDirs(CLAMVmQtPath+"/util")
extraPaths += recursiveDirs(CLAMVmQtPath+"/player")
extraPaths += recursiveDirs(CLAMVmQtPath+"/misc")
extraPaths += recursiveDirs(CLAMVmQtPath+"/widget")
extraPaths += [
	CLAMInstallDir+'/include',
	CLAMInstallDir+'/include/CLAM', # KLUDGE to keep old style includes
	'/usr/include/qt4/', # quick KLUDGE for ubuntu
	'/usr/include/qt4/QtCore', # quick KLUDGE for ubuntu
	'/usr/include/qt4/QtGui', # quick KLUDGE for ubuntu
	'/usr/include/qt4/QtOpenGl', # quick KLUDGE for ubuntu
]
includePaths = sourcePaths + extraPaths

qrcfiles = scanFiles("*.qrc", sourcePaths)
uifiles = scanFiles("*.ui", sourcePaths)
if len(uifiles): uiheaders = env.Uic4(source=uifiles)
sources = scanFiles('*.cxx', sourcePaths)
sources = filter( (lambda a : a.rfind( "moc_")==-1 ),  sources )
sources = filter( (lambda a : a.rfind( "qrc_")==-1 ),  sources )
if len(qrcfiles) : sources += env.Qrc(source=qrcfiles)
sources = dict.fromkeys(sources).keys()
sources.remove('./main.cxx')
sources.remove('./ClamExtractorExample.cxx')

env.Append(CPPPATH=includePaths)
env.Append(LIBPATH=CLAMVmQtPath)
env.Append(CPPFLAGS='-DRESOURCES_BASE="\\"' + env['install_prefix'] + '/share/annotator\\""')
env.Append(LIBS="clam_vmqt4")
env.ParseConfig('PKG_CONFIG_PATH=%s/lib/pkgconfig pkg-config %s --libs --cflags'%
	(
		CLAMInstallDir,
		' '.join(pkgconfigLibraries)) )
env.Append(CPPFLAGS=['-DFFTW_HEADER="<rfftw.h>"'])

if env['release'] :
	env.Append( CCFLAGS=['-O3','-fomit-frame-pointer','-Wall'] )
else :
	env.Append( CCFLAGS=['-g', '-Wall'] )
#env.Append( LINKFLAGS=['-rdynamic'] ) # TODO: Is it needed?

mainSources = {
	'Annotator' : './main.cxx',
	'ClamExtractorExample' : './ClamExtractorExample.cxx',
}

programs = []
for main in mainSources.items() :
	programs += [ env.Program(target=main[0], source = sources+[main[1]]) ]

sounds = [
	'../resources/sounds/click.wav'
	]
manpages = [
	'../resources/man/man1/Annotator.1',
	'../resources/man/man1/ClamExtractorExample.1',
	]

#env.AddPostAction( install_bin, 'chmod 755 $TARGET' ) # TODO: Look for a generic action
installation = {
	'/bin' : programs,
	'/share/man/man1' : manpages,
	'/share/annotator/sounds': sounds,
}
installTargets = [
	env.Install( env['install_prefix']+path, files ) for path, files in installation.items() ]

env.Alias( 'install', installTargets )
env.Default(programs)

