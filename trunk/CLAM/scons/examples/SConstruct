#!/usr/bin/python
import os
import glob
import sys
import SCons.Util
from SCons.Util import CLVar

def parse_pkg_config( env, libs) :
	if sys.platform != 'win32': return
	prefix = env['clam_prefix']
	descriptor_path = prefix + "\\lib\\pkgconfig\\"
	libpath = dict()
	libs = dict()
	cppflags = dict()
	cpppath = dict()
	ccflags = dict()
	for lib in libs :
		desc_file = descriptor_path + lib + ".pc"
		instream = open( desc_file )

		for line in instream :
			tokens = line.strip().split(' ')
			if tokens[0] == 'Libs:' :
				for token in tokens[1:] :
					if "/LIBPATH:" in token :
						libpath[token.replace("/LIBPATH:", "")] = True
					else :
						libs[token] = True
			elif tokens[0] == 'Cflags:':
				foo = line.strip().split(' /')
				for token in foo[1:] :
					token = '/' + token
					# search for -X flags
					if(token.find(' -')!=-1):
						listOfRealTokens = token.split(' -')
						#print('new token to parse: ' + token)
						firstToken = listOfRealTokens[0]
						if "/I" in firstToken:
							cpppath[ firstToken.replace("/I","") ] = True
						elif "/D" in firstToken :
							cppflags[ firstToken ] = True
						else :
							ccflags[firstToken] = True
						for realToken in listOfRealTokens[1:]:
							#print('new token to parse: ' + realToken)
							ccflags['-'+realToken] = True
					else:
						#print('new token to parse: ' + token)
						if "/I" in token :
							cpppath[ token.replace("/I","") ] = True
						elif "/D" in token in token :
							cppflags[ token ] = True
						else :
							#print('token: ' + token )
							ccflags[token] = True
			else :
				pass

		instream.close()
	env.Append( LIBPATH = libpath.keys() )
	env.Append( LIBS = libs.keys() )
	env.Append( CPPFLAGS = cppflags.keys() )
	env.Append( CCFLAGS = ccflags.keys() )
	env.Append( CPPPATH = cpppath.keys() )

qt4ToolPath="../sconstools"

options = Options('options.cache', ARGUMENTS)
options.Add(PathOption('clam_prefix', 'The prefix where CLAM was installed', ''))

def scanFiles(pattern, paths) :
	files = []
	for path in paths :
		files+=glob.glob(path+"/"+pattern)
	return files

def recursiveDirs(root) :
	return filter( (lambda a : a.rfind( "CVS")==-1 ),  [ a[0] for a in os.walk(root)]  )

def unique(list) :
	return dict.fromkeys(list).keys()

env = Environment(tools=['default','qt'], toolpath=[qt4ToolPath], options=options)
options.Save('options.cache', env)
CLAMInstallDir = env['clam_prefix']

env.SConsignFile() # Single signature file

env['CXXFILESUFFIX'] = '.cxx'
env['QT_MOCHPREFIX'] = 'generated/moc_'
env['QT_UICDECLPREFIX'] = 'generated/ui_'
env['QT_UICDECLSUFFIX'] = '.hxx'
if (sys.platform == 'linux2') :
	env['QT_LIB'] = 'qt-mt'
if (sys.platform == 'win32') :
	env['QT_LIB'] = 'qt-mt322'

pkgconfigLibraries = [
	'clam_core',
	'clam_audioio',
	'clam_processing',
	'clam_vmfl',
	'clam_vmqt',
]

sourcePaths = []
#sourcePaths += recursiveDirs("..")
extraPaths = []
extraPaths += recursiveDirs("examples/utils")
extraPaths += [
	CLAMInstallDir+'/include',
	CLAMInstallDir+'/include/CLAM', # KLUDGE to keep old style includes	
]
includePaths = sourcePaths + extraPaths

sources = scanFiles('*.cxx', sourcePaths)
sources = unique(sources)

env.Append(CPPPATH=includePaths)
env.ParseConfig('PKG_CONFIG_PATH=%s/lib/pkgconfig pkg-config %s --libs --cflags'%
	(
		CLAMInstallDir,
		' '.join(pkgconfigLibraries)))
parse_pkg_config(env, pkgconfigLibraries)
env.Append(CPPFLAGS=['-DFFTW_HEADER="<rfftw.h>"'])

singleSourceExamples = [
	"../../examples/NetworkPersistence_example.cxx",
	"../../examples/NetworkUsage_example.cxx",
#	"../../examples/AudioApplicationExample.cxx", # TODO: Windows lacks GUIAudioApplication
	"../../examples/AudioFileReading_example.cxx",
	"../../examples/AudioFileWriting_example.cxx",
	"../../examples/AudioIOExample.cxx",
	"../../examples/Configurators_example.cxx",
	"../../examples/DescriptorComputation_example.cxx",
	"../../examples/FDFilterExample.cxx",
	"../../examples/FFT_example.cxx",
	"../../examples/FileInfo_example.cxx",
	"../../examples/FilePlayback_example.cxx",
	"../../examples/FundamentalDetect.cxx",
	"../../examples/LPCAnalysis_example.cxx",
	"../../examples/Midi2XmlExample.cxx",
	"../../examples/MIDIFileReadWriteExample.cxx",
	"../../examples/MIDIIOExample.cxx",
	"../../examples/MIDIOut_example.cxx",
#	"../../examples/MIDI_Synthesizer_example/MIDI_Synthesizer_example.cxx", # TODO: Windows lacks GUIAudioApplication
	"../../examples/NetworkPersistence_example.cxx",
	"../../examples/NetworkUsage_example.cxx",
	"../../examples/PersistenceThroughDTs_example.cxx",
#	"../../examples/MultiPlot_example.cxx",
#	"../../examples/PlotExamplesHelper.cxx",
#	"../../examples/SinglePlot_example.cxx",
	"../../examples/POCompositeExample.cxx",
	"../../examples/PortsExamples/SimplePortsUsage_example.cxx",
	"../../examples/ProcessingLifeCycle_example.cxx",
	"../../examples/ProcessingObject_controls_example.cxx",
	"../../examples/SDIF_And_Segment_example.cxx",
	"../../examples/Spectrum_example.cxx",
	"../../examples/StereoToMonoFile.cxx",
#	"../../examples/StreamBufferExample.cxx", # TODO: Deprecated?
#	"../../examples/ThreadedProcessing_example.cxx", # TODO: Depends on Resample
	"../../examples/Tutorial/UserTutorial1.cxx",
	"../../examples/Tutorial/UserTutorial2.cxx",
	"../../examples/Tutorial/UserTutorial3.cxx",
	"../../examples/Tutorial/UserTutorial4.cxx",
	"../../examples/Tutorial/UserTutorial5.cxx",
	"../../examples/Tutorial/UserTutorial6.cxx",
]
# TODO: Weird ones (libraries, client server...)
#	"../../examples/CLT/LadspaAudioMultiplier.cxx",
#	"../../examples/CLT/LadspaSimpleOscillator.cxx",
# TODO: Files to be integred on the Network editor
#	"../../examples/CLAMRemoteController/CLAMRemoteController.cxx",
#	"../../examples/CLAMRemoteController/LADSPAHandler.cxx",
#	"../../examples/NetworkLADSPAPlugin/LADSPAHandler.cxx",
#	"../../examples/NetworkLADSPAPlugin/NetworkLADSPAPlugin.cxx",
#	"../../examples/QtDesignerPlugins/CLAMWidgetsPlugin.cxx",
qtPlotUtils = [
	"../../examples/QtPlots/utils/analysis_utils.cxx",
	"../../examples/QtPlots/utils/audio_file_utils.cxx",
	"../../examples/QtPlots/utils/wave_utils.cxx",
]
qtPlotMains = [
#	"../../examples/QtPlots/BPFEditorExample/BPFEditorExample.cxx", #TODO: Windows needs PortMidi
	"../../examples/QtPlots/DirectPlotsExamples/DPAudioExample.cxx",
	"../../examples/QtPlots/DirectPlotsExamples/DPAudioStereoExample.cxx",
	"../../examples/QtPlots/DirectPlotsExamples/DPFundamentalExample.cxx",
	"../../examples/QtPlots/DirectPlotsExamples/DPMultiPlotExample.cxx",
	"../../examples/QtPlots/DirectPlotsExamples/DPSpectrumAndPeaksExample.cxx",
#	"../../examples/QtPlots/DirectPlotsExamples/MultiBPFViewerExample.cxx", #TODO: Windows needs PortMidi
#	"../../examples/QtPlots/ListPlotExample/ListPlotExample.cxx", #TODO: Windows needs PortMidi
	"../../examples/QtPlots/QtPlotsExamples/QtAudioPlotExample.cxx",
	"../../examples/QtPlots/QtPlotsExamples/QtSinTracksPlotExample.cxx",
	"../../examples/QtPlots/QtPlotsExamples/QtSpectrogramExample.cxx",
	"../../examples/QtPlots/QtPlotsExamples/QtSpectrumPlotExample.cxx",
	"../../examples/QtPlots/SegmentEditorExample/SegmentEditorExample.cxx",
]

directoryBasedExamples = [
#	"../../examples/TickExtractor", # TODO: Files left to be compilable
	"../../examples/PortsAndControlsUsageExample",
	"../../examples/ControlArrayExamples",
]

prototypers = [
#	"../../examples/Prototyper/PAPrototyper.cxx",
	"../../examples/Prototyper/BlockingPrototyper.cxx",
]
if sys.platform != "win32" :
	prototypers += "../../examples/Prototyper/JACKPrototyper.cxx",
prototyperHelpers = [
	"../../examples/Prototyper/PrototypeLoader.cxx",
	"../../examples/Prototyper/QtSlot2Control.cxx",
]

examples = []

for main in singleSourceExamples :
	executable = os.path.splitext(os.path.basename(main))[0]
	examples += [ env.Program(target=executable, source = sources + [main] ) ]
	
env.AppendUnique(CPPPATH=["../../examples/QtPlots/utils"])
for main in qtPlotMains :
	executable = os.path.splitext(os.path.basename(main))[0]
	examples += [ env.Program(target=executable, source = sources + [main] + qtPlotUtils) ]

for folder in directoryBasedExamples :
	exampleSources = glob.glob(folder+"/*.cxx")
	executable = os.path.basename(folder)
	examples += [ env.Program(target=executable, source = sources + exampleSources ) ]

env.AppendUnique(LIBS=["qui"])
for main in prototypers :
	executable = os.path.splitext(os.path.basename(main))[0]
	examples += [ env.Program(target=executable, source = sources + [main] + prototyperHelpers) ]


env.Alias('examples',examples)

env.Default(examples)



