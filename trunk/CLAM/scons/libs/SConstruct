import sys
import os
import shelve
import copy
# tools for build configuration
from buildtools import *
from buildtools.custom_builders import * 
from buildtools.thorough_check import ThoroughPackageCheck
from buildtools.tool_checks import *
from buildtools.package_checks import *
from buildtools.generic_checks import *
from buildtools.installdirs import * 
from buildtools.dmg_creation import *
from buildtools.rulesets import handle_preinclude
# module check sequences
from modconf import *
from modconf.core import * 
from modconf.processing import *
from modconf.audioio import *
from modconf.vmqt import *
from modconf.vmfl import *

def load_config_file_to_env( env, dir ):
	opts = Options(dir+'/flags.conf')
	opts.Add( 'CPPPATH', 'CPP PATH', env['CPPPATH'])
	opts.Add( 'CCFLAGS', 'CC FLAGS', env['CCFLAGS'])
	opts.Add( 'CPPFLAGS', 'CPP FLAGS', env['CPPFLAGS'])
	opts.Add( 'LIBPATH', 'LIB PATH', env['LIBPATH'])
	opts.Add( 'LIBS', 'libs to link', env['LIBS'])
	opts.Add( 'pkg_config_available', 'PKG Config Available', 'False')
	opts.Add( 'QT_LIB', 'QT lib name', 'qt-mt')
	opts.Update(env)

def save_config_file_from_env( env, dir ):
	# workaround due to bug in scons (if we add the flag after loading it will add "" to the new flagand will fail
	handle_preinclude(env)
	opts = Options()
	opts.Add( 'CPPPATH', 'CPP PATH', '')
	opts.Add( 'CCFLAGS', 'CC FLAGS', '')
	opts.Add( 'CPPFLAGS', 'CPP FLAGS', '')
	opts.Add( 'LIBPATH', 'LIB PATH', '')
	opts.Add( 'LIBS', 'libs to link', env['LIBS'])
	opts.Add( 'pkg_config_available', 'PKG Config Available', 'False')
	opts.Add( 'QT_LIB', 'QT lib name', '')
	opts.Save(dir+'/flags.conf', env)

def configure_clam(clam_env) :
	print """\
############################################
### CLAM GLOBAL DEPENDENCIES CHECKING    ###
############################################"""
	if sys.platform == 'win32' :
		clam_env.Replace( QT_LIB = 'qt-mt322')
	else :
		clam_env.Replace( QT_LIB = 'qt-mt' )

	# Sandbox setup
	if sys.platform == 'win32' : #!= 'linux2' :
		libbasenames = [ 'fltk', 'xercesc', 'fftw', 'dxsdk', 'id3lib', 'libmad', 'libsndfile','oggvorbis','portmidi','pthreads']
		for basename in libbasenames :
			if sys.platform == 'win32' : path_sep = '\\'
			if sys.platform == 'darwin' : path_sep = '/'

			include_path = "%s%s%s%s%s"%(clam_env['sandbox_path'],path_sep,basename,path_sep,'include')
			print( 'include path: ' + include_path )
			lib_path =  "%s%s%s%s%s"%(clam_env['sandbox_path'],path_sep,basename,path_sep,'lib')
			print( 'lib path: ' + lib_path)
			clam_env.Append( CPPPATH= include_path )
			clam_env.Append( LIBPATH = lib_path )
			# if flags is not defined it will crash while loading flags.conf
		environmentIncludes = os.environ['INCLUDE']
		environmentIncludesList = environmentIncludes.split(';')
		for include in environmentIncludesList :
			print( 'adding include dir from windows config: ' + include )
			clam_env.Append( CPPPATH = include)
	else:
		clam_env.Append( CPPPATH= '/usr/local/include' )

	conf = Configure( clam_env, custom_tests = custom_check_routines )
	if not setup_global_environment( clam_env, conf ) :
		Exit(1)
	clam_env = conf.Finish()

def configure_core(core_env) :
	print """\
#########################################
### CLAM CORE DEPENDENCIES CHECKING   ###
#########################################"""
	conf = Configure( core_env, custom_tests = custom_check_routines )
	core_env.Replace( QT_LIB = '' )
	if not setup_core_environment( core_env, conf ) :
		Exit(1)
	core_env = conf.Finish()
	clam_env['xmlbackend'] = core_env['xmlbackend']
	if clam_env['xmlbackend'] != 'none' :
		clam_env.Append( CPPFLAGS=['-DCLAM_USE_XML'] )

def configure_processing(processing_env) :
	print """\
###############################################
### CLAM PROCESSING DEPENDENCIES CHECKING   ###
###############################################"""
	if sys.platform == 'win32' or sys.platform == 'darwin' :
		#Added 'darwin' because due to some strange reasons, the LIBS added in the previous setup_core_environment were not used anymore (but CPPFLAGS did).
		# In Linux it works fine without having to manually copy them --> done before every module process in this file
		processing_env.AppendUnique( LIBS=copy.copy(core_env['LIBS']) )
	conf = Configure( processing_env, custom_check_routines )	
	processing_env.Replace( QT_LIB = '' )
	if not setup_processing_environment( processing_env, conf ) :
		Exit(1)
	processing_env = conf.Finish()

def configure_audioio(audioio_env) :
	print """\
############################################
### CLAM AUDIOIO DEPENDENCIES CHECKING   ###
############################################"""
	if sys.platform == 'win32' or sys.platform == 'darwin' :
		audioio_env.AppendUnique( LIBS=copy.copy(core_env['LIBS']) )
		audioio_env.AppendUnique( LIBS=copy.copy(processing_env['LIBS']) )
		audioio_env.AppendUnique( LINKFLAGS=copy.copy(core_env['LINKFLAGS']) )

	conf = Configure( audioio_env, custom_check_routines )
	audioio_env.Replace( QT_LIB = '' )
	if not setup_audioio_environment( audioio_env, conf ) :
		Exit(1)
	audioio_env = conf.Finish()

def configure_vmfl(vmfl_env) :	
	print """\
#########################################
### CLAM VMFL DEPENDENCIES CHECKING   ###
#########################################"""
	if sys.platform != 'darwin':  # FLTK configuration bypass under Mac OSX
		if sys.platform == 'win32' or sys.platform == 'darwin' :
			vmfl_env.AppendUnique( LIBS=copy.copy(core_env['LIBS']) )
			vmfl_env.AppendUnique( LIBS=copy.copy(processing_env['LIBS']) )
			vmfl_env.AppendUnique( LIBS=copy.copy(audioio_env['LIBS']) )
		conf = Configure( vmfl_env, custom_check_routines )
		vmfl_env.Replace( QT_LIB = '' )
		if not setup_vmfl_environment( vmfl_env, conf ) :
			Exit(1)
		vmfl_env = conf.Finish()

def configure_vmqt(vmqt_env) :	
	print """\
#########################################
### CLAM VMQT DEPENDENCIES CHECKING   ###
#########################################"""
	if sys.platform == 'win32' or sys.platform == 'darwin' :
		vmqt_env.AppendUnique( LIBS=copy.copy(core_env['LIBS']) )
		vmqt_env.AppendUnique( LIBS=copy.copy(processing_env['LIBS']) )
		vmqt_env.AppendUnique( LIBS=copy.copy(audioio_env['LIBS']) )
	vmqt_env.Replace( QT_DEBUG='0' )
	conf = Configure( vmqt_env, custom_check_routines )
	if not setup_vmqt_environment( vmqt_env, conf ) :
		Exit(1)
	vmqt_env = conf.Finish()

def configureBB( clam_env ) :
	configure_clam(clam_env)

	core_env = clam_env.Copy()
	processing_env = clam_env.Copy()
	audioio_env = clam_env.Copy()
	vmfl_env = clam_env.Copy()
	vmqt_env = clam_env.Copy()

	configure_core(core_env)
	configure_processing(processing_env)
	configure_audioio(audioio_env)
	configure_vmfl(vmfl_env)
	configure_vmqt(vmqt_env)

	save_config_file_from_env(clam_env, '.')
	save_config_file_from_env(core_env, 'core')
	save_config_file_from_env(processing_env, 'processing')
	save_config_file_from_env(audioio_env, 'audioio')
	save_config_file_from_env(vmfl_env, 'vmfl')
	save_config_file_from_env(vmqt_env, 'vmqt')
	#return core_env, processing_env, audioio_env, vmfl_env, vmqt_env

#def configure_foo( target, source, env ):
#	configure_core(core_env)

#def configure_message_foo( target, source, env ):
#	return "configuring CLAM"

# helper functions
def setup_build_options( env ) :
	# configuration options:
	opts = Options('clam.conf')
	
	# global options
	if sys.platform == 'linux2' :
		opts.Add( PathOption( 'prefix', 'Directory to install under', '/usr'))
	elif sys.platform == 'darwin' :
		opts.Add( PathOption( 'prefix', 'Directory to install under (warning: do not set /usr)', '/usr/local'))
	else :
		opts.Add( PathOption( 'prefix', 'Directory to install under', 'G:\\projects\CLAM-bin') )

	opts.Add( PathOption( 'install_prefix', 'Directory to install under (for packagers)', '.'))
	if sys.platform == 'win32' : #!= 'linux2' :
		opts.Add( PathOption( 'sandbox_path', 'Path to sandbox', 'G:\\projects' ) )
	if sys.platform == 'win32' :
		opts.Add( BoolOption( 'release', 'Build CLAM with optimizations and stripping debug symbols', 'no' ))
	else :
		opts.Add( BoolOption( 'release', 'Build CLAM with optimizations and stripping debug symbols', 'yes'))
	opts.Add( BoolOption( 'double', 'CLAM TData type will be double','no'))
	opts.Add( BoolOption( 'sandbox', 'Presence of libraries in the CLAM sandbox will have preference', 'yes'))
	opts.Add( BoolOption( 'checks', 'Postcondition checks enabled', 'yes' ))

	opts.Add( BoolOption( 'release_asserts', 'CLAM asserts will be triggered on release builds', 'no'))
	
	# clam_core options
	opts.Add( EnumOption( 'xmlbackend', 'XML passivation backend', 'xercesc', ('xercesc','xmlpp','both','none')) )
	if sys.platform != 'win32' :
		opts.Add( BoolOption( 'with_ladspa_support', 'Ladspa plugin support', 'yes') )
		opts.Add( BoolOption( 'with_osc_support', 'Enables/Disables OSC support', 'yes') )
		opts.Add( BoolOption( 'with_jack_support', 'Enables/Disable JACK support', 'yes') )
	
	# clam_processing options
	opts.Add( BoolOption( 'with_fftw', 'Selects whether to use fftw or not', 'yes'))
	opts.Add( BoolOption( 'with_nr_fft', 'Selects whether to use Numerical Recipes fft algorithm implementation or not', 'yes') )

	# clam_audioio options
	opts.Add( BoolOption( 'with_sndfile', 'Enables PCM files reading and writing', 'yes' ) )	
	opts.Add( BoolOption( 'with_oggvorbis', 'Enables ogg/vorbis reading and writing support', 'yes' ) )
	opts.Add( BoolOption( 'with_mad', 'Enables mpeg 1 layer 3 files reading and writing support', 'yes' ) )
	opts.Add( BoolOption( 'with_id3', 'Enables support for accesing ID3 tags on mpeg audio streams', 'yes') )
	if sys.platform == 'linux2' :
		opts.Add( BoolOption( 'with_alsa', 'Enables PCM and MIDI device I/O through ALSA', 'yes' ) )
	elif sys.platform == 'darwin' :
		opts.Add( EnumOption( 'audio_backend', 'Selects audio PCM i/o library used by CLAM backend', 'rtaudio', ('rtaudio','portaudio') ) )
	elif sys.platform == 'win32' :
		opts.Add( EnumOption( 'audio_backend', 'Selects audio PCM i/o library used by CLAM backend', 'rtaudio', ('rtaudio','directx','portaudio') ) )
	opts.Add( BoolOption( 'with_portmidi', 'Enables MIDI device I/O through portmidi', 'no' ) )

	# clam_vmqt options
	if sys.platform == 'linux2' :
		opts.Add( PathOption( 'qt_includes', 'Path to the directory where qt includes are located', '/usr/include/qt3' ) )
		opts.Add( PathOption( 'qt_libs', 'Path to the directory where qt binaries are located', '/usr/lib' ) )
	elif sys.platform == 'darwin' :
		opts.Add( PathOption( 'qt_includes', 'Path to the directory where qt includes are located', '/Developer/qt/include' ) )
		opts.Add( PathOption( 'qt_libs', 'Path to the directory where qt binaries are located', '/Developer/qt/lib' ) )
	elif sys.platform == 'win32' :
		opts.Add( PathOption( 'qt_includes', 'Path to the directory where qt includes are located', 'G:\projects\qt\include' ) )
		opts.Add( PathOption( 'qt_libs', 'Path to the directory where qt binaries are located', 'G:\projects\qt\lib' ) )
		
	
	opts.Update(env)
	opts.Save('clam.conf', env) # Save, so user doesn't have to 
				  				# specify PREFIX every time

	Help(opts.GenerateHelpText(env))

def compose_install_dirnames( env ) :
	install_dirs = InstallDirs()
	install_dirs.compose( env )
	Export('install_dirs')
	print """\
#############################################
### INSTALL DIRECTORY INFORMATION         ###
#############################################"""
	print "Directory to install under:", install_dirs.prefix
	print "\tLibrary files will be installed at:", install_dirs.lib
	print "\tExecutable files will be installed at:", install_dirs.bin
	print "\tInclude files will be installed at:", install_dirs.inc
	print "\tDocumentation, data and examples will be installed at:", install_dirs.data

def gather_custom_checks() :
	custom_check_routines = dict()

	for check_name, check_routine in package_checks.items() :
		custom_check_routines[check_name] = check_routine

	for check_name, check_routine in tool_checks.items() :
		custom_check_routines[check_name] = check_routine

	for check_name, check_routine in generic_checks.items() :
		custom_check_routines[check_name] = check_routine

	return custom_check_routines

def create_custom_builders( env ) :
	bld = Builder( action=Action(generate_so_name,generate_so_name_message) )
	env.Append( BUILDERS={'SonameLink' : bld} )	
	bld = Builder( action=Action(generate_linker_name, generate_linker_name_message) )
	env.Append( BUILDERS={'LinkerNameLink' : bld} )

# SConstruct file for CLAM
# Main section

version = '0.90-pre3'
Export('version')

top = '../..'
Export('top')

clam_env = Environment( ENV=os.environ, tools=['default','qt'])


if not clam_env.GetOption("clean") :
	header_db = shelve.open( 'header.db' )
else :
	header_db = None
Export('header_db')

clam_env['preinclude']='preinclude.hxx'

setup_build_options( clam_env )

clam_env.Append( CPPFLAGS = '' )
clam_env['preinclude'] = 'preinclude.hxx'

Export('clam_env')

#registering custom checks
custom_check_routines = gather_custom_checks()

#registering custom_builders
create_custom_builders(clam_env)

core_env = clam_env.Copy()
processing_env = clam_env.Copy()
audioio_env = clam_env.Copy()
vmfl_env = clam_env.Copy()
vmqt_env = clam_env.Copy()

if 'configure' in COMMAND_LINE_TARGETS:
    configureBB(clam_env)
    print "Finished. Invoke 'scons' now."
    Exit(0)

#building
if not clam_env.GetOption('clean') :
	load_config_file_to_env(core_env, 'core')
	load_config_file_to_env(processing_env, 'processing')
	load_config_file_to_env(audioio_env, 'audioio')
	load_config_file_to_env(vmfl_env, 'vmfl')
	load_config_file_to_env(vmqt_env, 'vmqt')


Export('core_env')
Export('processing_env')
Export('audioio_env')
Export('vmfl_env')
Export('vmqt_env')

# install dirs composition

compose_install_dirnames(clam_env)

if clam_env.GetOption('clean') :
	if os.path.exists( 'header.db' ) :
		os.remove('header.db')


core_tgt, core_install_tgt = SConscript('core/SConscript')
processing_tgt, processing_install_tgt = SConscript('processing/SConscript')
audioio_tgt, audioio_install_tgt = SConscript('audioio/SConscript')
vmfl_tgt, vmfl_install_tgt = SConscript('vmfl/SConscript')
vmqt_tgt, vmqt_install_tgt = SConscript('vmqt/SConscript')

# Module dependencies
if sys.platform != 'darwin':
	all_alias = Alias( 'all', [core_tgt, processing_tgt, audioio_tgt, vmfl_tgt, vmqt_tgt] )
	install_alias = Alias( 'install', [core_install_tgt, processing_install_tgt, audioio_install_tgt, vmfl_install_tgt, vmqt_install_tgt] )

else:
	all_alias = Alias( 'all', [core_tgt, processing_tgt, audioio_tgt, vmqt_tgt] )
	install_alias = Alias( 'install', [core_install_tgt, processing_install_tgt, audioio_install_tgt, vmqt_install_tgt] )

	#DMG creation process
	dmg_bld = Builder( action=Action( create_dmg, create_dmg_message ))
	clam_env.Append( BUILDERS={'CreateDMG' : dmg_bld} )
	dmg = clam_env.CreateDMG( version, None )
	clam_env.Alias('dmg', [ all_alias, dmg])

Default( all_alias )
print """\
##############################################
### BUILDING CLAM LIBRARIES                ###
##############################################"""
