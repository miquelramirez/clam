import sys
import os
import shelve
# tools for build configuration
from buildtools import *
from buildtools.custom_builders import * 
from buildtools.thorough_check import ThoroughPackageCheck
from buildtools.tool_checks import *
from buildtools.package_checks import *
from buildtools.generic_checks import *
from buildtools.installdirs import * 
# module check sequences
from modconf import *
from modconf.core import * 
from modconf.processing import *
from modconf.audioio import *
from modconf.vmfl import *
from modconf.vmqt import *

# helper functions
def setup_build_options( env ) :
	# configuration options:
	opts = Options('clam.conf')
	
	# global options
	opts.Add( PathOption( 'prefix', 'Directory to install under', '/usr'))
	opts.Add( BoolOption( 'release', 'Build CLAM using optimization and stripping debug symbols', 'yes'))
	opts.Add( BoolOption( 'double', 'CLAM TData type will be double','no'))
	opts.Add( BoolOption( 'sandbox', 'Presence of libraries in the CLAM sandbox will have preference', 'yes'))
	opts.Add( BoolOption( 'checks', 'Postcondition checks enabled', 'yes' ) )
	opts.Add( BoolOption( 'release_asserts', 'CLAM asserts will be triggered on release builds', 'no'))
	
	# clam_core options
	opts.Add( EnumOption( 'xmlbackend', 'XML passivation backend', 'xercesc', ('xercesc','xmlpp','both','none')) )
	opts.Add( BoolOption( 'with_ladspa_support', 'Ladspa plugin support', 'yes') )
	opts.Add( BoolOption( 'with_osc_support', 'Enables/Disables OSC support', 'yes') )
	
	# clam_processing options
	opts.Add( BoolOption( 'with_fftw', 'Selects whether to use fftw or not', 'yes'))
	opts.Add( BoolOption( 'with_nr_fft', 'Selects whether to use Numerical Recipes fft algorithm implementation or not', 'yes') )

	# clam_audioio options
	opts.Add( BoolOption( 'with_sndfile', 'Enables PCM files reading and writing', 'yes' ) )	
	opts.Add( BoolOption( 'with_oggvorbis', 'Enables ogg/vorbis reading and writing support', 'yes' ) )
	opts.Add( BoolOption( 'with_mad', 'Enables mpeg 1 layer 3 files reading and writing support', 'yes' ) )
	opts.Add( BoolOption( 'with_id3', 'Enables support for accesing ID3 tags on mpeg audio streams', 'yes') )
	if sys.platform == 'linux2' :
		opts.Add( BoolOption( 'with_alsa', 'Enables PCM and MIDI device I/O through ALSA', 'yes' ) )
	elif sys.platform == 'win32' :
		opts.Add( BoolOption( 'audio_backend', 'Selects audio PCM i/o library used by CLAM backend', 'rtaudio', ('rtaudio','directx','portaudio') ) )
	else :
		opts.Add( BoolOption( 'audio_backend', 'Selects audio PCM i/o library used CLAM backend', 'rtaudio', ('rtaudio',) ) )
	opts.Add( BoolOption( 'with_portmidi', 'Enables MIDI device I/O through portmidi', 'no' ) )

	# clam_vmqt options
	opts.Add( PathOption( 'qt_includes', 'Path to the directory where qt includes are located', '/usr/include/qt3' ) )
	opts.Add( PathOption( 'qt_libs', 'Path to the directory where qt binaries are located', '/usr/lib' ) )
	
	opts.Update(env)
	opts.Save('clam.conf', env) # Save, so user doesn't have to 
				  				# specify PREFIX every time

	Help(opts.GenerateHelpText(env))

def compose_install_dirnames( env ) :
	install_dirs = InstallDirs()
	install_dirs.compose( env )
	Export('install_dirs')
	print """\
#############################################
### INSTALL DIRECTORY INFORMATION         ###
#############################################"""
	print "Directory to install under:", install_dirs.prefix
	print "\tLibrary files will be installed at:", install_dirs.lib
	print "\tExecutable files will be installed at:", install_dirs.bin
	print "\tInclude files will be installed at:", install_dirs.inc
	print "\tDocumentation, data and examples will be installed at:", install_dirs.data

def gather_custom_checks() :
	custom_check_routines = dict()

	for check_name, check_routine in package_checks.items() :
		custom_check_routines[check_name] = check_routine

	for check_name, check_routine in tool_checks.items() :
		custom_check_routines[check_name] = check_routine

	for check_name, check_routine in generic_checks.items() :
		custom_check_routines[check_name] = check_routine

	return custom_check_routines

def create_custom_builders( env ) :
	bld = Builder( action=Action(generate_so_name,generate_so_name_message) )
	env.Append( BUILDERS={'SonameLink' : bld} )	
	bld = Builder( action=Action(generate_linker_name, generate_linker_name_message) )
	env.Append( BUILDERS={'LinkerNameLink' : bld} )

# SConstruct file for CLAM
# Main section

version = '0.8'
Export('version')

top = '../..'
Export('top')

clam_env = Environment( ENV=os.environ, tools=['default','qt'])
clam_env.Replace( QT_LIB = 'qt-mt' )
Export('clam_env')

header_db = shelve.open( 'header.db' )
Export('header_db')

setup_build_options( clam_env )

if not clam_env.GetOption('clean') :

	#registering custom checks
	custom_check_routines = gather_custom_checks()

#registering custom_builders
create_custom_builders(clam_env)


if not clam_env.GetOption('clean') :

	print """\
############################################
### CLAM GLOBAL DEPENDENCIES CHECKING    ###
############################################"""

	conf = Configure( clam_env, custom_tests = custom_check_routines )
	if not setup_global_environment( clam_env, conf ) :
		Exit(1)
	clam_env = conf.Finish()

print """\
############################################
### CLAM MODULES DEPENDENCIES CHECKING   ###
############################################"""

# core env, CLAM core module checks
core_env = clam_env.Copy()
Export('core_env')
core_env.Replace( QT_LIB = '' )

if not clam_env.GetOption('clean') :

	conf = Configure( core_env, custom_tests = custom_check_routines )
	if not setup_core_environment( core_env, conf ) :
		Exit(1)
	core_env = conf.Finish()
	clam_env['xmlbackend'] = core_env['xmlbackend']
	if clam_env['xmlbackend'] != 'none' :
		clam_env.Append( CPPFLAGS=['-DCLAM_USE_XML'] )


processing_env = clam_env.Copy()
Export('processing_env')
processing_env.Replace( QT_LIB = '' )

if not clam_env.GetOption('clean') :
	conf = Configure( processing_env, custom_check_routines )
	if not setup_processing_environment( processing_env, conf ) :
		Exit(1)
	processing_env = conf.Finish()


audioio_env = clam_env.Copy()
Export('audioio_env')
audioio_env.Replace( QT_LIB = '' )

if not clam_env.GetOption('clean') :
	conf = Configure( audioio_env, custom_check_routines )
	if not setup_audioio_environment( audioio_env, conf ) :
		Exit(1)
	audioio_env = conf.Finish()


vmfl_env = clam_env.Copy()
Export('vmfl_env')
vmfl_env.Replace( QT_LIB = '' )

if not clam_env.GetOption('clean') :
	conf = Configure( vmfl_env, custom_check_routines )
	if not setup_vmfl_environment( vmfl_env, conf ) :
		Exit(1)
	vmfl_env = conf.Finish()

vmqt_env = clam_env.Copy()
vmqt_env.Replace( QT_DEBUG='1' )
Export('vmqt_env')

if not clam_env.GetOption('clean') :
	conf = Configure( vmqt_env, custom_check_routines )
	if not setup_vmqt_environment( vmqt_env, conf ) :
		Exit(1)
	vmqt_env = conf.Finish()

# install dirs composition
compose_install_dirnames(clam_env)

if clam_env.GetOption('clean') :
	os.remove('header.db')

#building

core_tgt, core_install_tgt = SConscript('core/SConscript')
processing_tgt, processing_install_tgt = SConscript('processing/SConscript')
audioio_tgt, audioio_install_tgt = SConscript('audioio/SConscript')
vmfl_tgt, vmfl_install_tgt = SConscript('vmfl/SConscript')
vmqt_tgt, vmqt_install_tgt = SConscript('vmqt/SConscript')

# Module dependencies
#Depends( processing_tgt, core_tgt )
#Depends( audioio_tgt, [processing_tgt, core_tgt] )
#Depends( vmfl_tgt, [core_tgt, processing_tgt, audioio_tgt] )
#Depends( vmqt_tgt, [core_tgt, processing_tgt, audioio_tgt, vmfl_tgt] )

all_alias = Alias( 'all', [core_tgt, processing_tgt, audioio_tgt, vmfl_tgt, vmqt_tgt ] )
install_alias = Alias( 'install', [core_install_tgt, processing_install_tgt, audioio_install_tgt, vmfl_install_tgt, vmqt_install_tgt] )

Depends( install_alias, all_alias )

Default( all_alias )
print """\
##############################################
### BUILDING CLAM LIBRARIES                ###
##############################################"""
