// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/value_traits.hpp"

#include "boost/python/suite/indexing/container_suite.hpp"

#include "boost/python/suite/indexing/vector.hpp"

#include "boost/python/suite/indexing/map.hpp"

#include "boost/python/suite/indexing/list.hpp"

#include "CLAM/Flags.hxx"

#include "CLAM/SpecTypeFlags.hxx"

#include "CLAM/Component.hxx"

#include "CLAM/Storage.hxx"

#include "CLAM/XMLStorage.hxx"

#include "CLAM/FFT.hxx"

#include "CLAM/FFT_base.hxx"

#include "CLAM/FFT_ooura.hxx"

#include "CLAM/OutControl.hxx"

#include "CLAM/InControl.hxx"

#include "CLAM/Processing.hxx"

#include "CLAM/ProcessingConfig.hxx"

#include "CLAM/ProcessingData.hxx"

#include "CLAM/ProcessingDataConfig.hxx"

#include "CLAM/ProcessingDataPlugin.hxx"

#include "CLAM/FlowControl.hxx"

#include "CLAM/FlattenedNetwork.hxx"

#include "CLAM/Network.hxx"

#include "CLAM/NetworkPlayer.hxx"

#include "CLAM/DataTypes.hxx"

#include "CLAM/Enum.hxx"

#include "CLAM/CLAM_Math.hxx"

#include "CLAM/Err.hxx"

#include "Definitions.hxx"

namespace bp = boost::python;

struct Component_wrapper : CLAM::Component, bp::wrapper< CLAM::Component > {

    Component_wrapper()
    : CLAM::Component()
      , bp::wrapper< CLAM::Component >(){
        // null constructor
        
    }

    virtual ::CLAM::Component * DeepCopy(  ) const  {
        if( bp::override func_DeepCopy = this->get_override( "DeepCopy" ) )
            return func_DeepCopy(  );
        else
            return this->CLAM::Component::DeepCopy(  );
    }
    
    
    ::CLAM::Component * default_DeepCopy(  ) const  {
        return CLAM::Component::DeepCopy( );
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

    virtual void LoadFrom( ::CLAM::Storage & storage ){
        bp::override func_LoadFrom = this->get_override( "LoadFrom" );
        func_LoadFrom( boost::ref(storage) );
    }

    virtual ::CLAM::Component * ShallowCopy(  ) const  {
        if( bp::override func_ShallowCopy = this->get_override( "ShallowCopy" ) )
            return func_ShallowCopy(  );
        else
            return this->CLAM::Component::ShallowCopy(  );
    }
    
    
    ::CLAM::Component * default_ShallowCopy(  ) const  {
        return CLAM::Component::ShallowCopy( );
    }

    virtual void StoreOn( ::CLAM::Storage & storage ) const {
        bp::override func_StoreOn = this->get_override( "StoreOn" );
        func_StoreOn( boost::ref(storage) );
    }

};

struct Enum_wrapper : CLAM::Enum, bp::wrapper< CLAM::Enum > {

    Enum_wrapper(::CLAM::Enum::tEnumValue const * values, int const & value )
    : CLAM::Enum( boost::python::ptr(values), value )
      , bp::wrapper< CLAM::Enum >(){
        // constructor
    
    }

    Enum_wrapper(::CLAM::Enum::tEnumValue const * values, ::std::string const & value )
    : CLAM::Enum( boost::python::ptr(values), value )
      , bp::wrapper< CLAM::Enum >(){
        // constructor
    
    }

    virtual ::CLAM::Component * DeepCopy(  ) const  {
        if( bp::override func_DeepCopy = this->get_override( "DeepCopy" ) )
            return func_DeepCopy(  );
        else
            return this->CLAM::Enum::DeepCopy(  );
    }
    
    
    ::CLAM::Component * default_DeepCopy(  ) const  {
        return CLAM::Enum::DeepCopy( );
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::Enum::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::Enum::GetClassName( );
    }

    virtual void LoadFrom( ::CLAM::Storage & storage ) {
        if( bp::override func_LoadFrom = this->get_override( "LoadFrom" ) )
            func_LoadFrom( boost::ref(storage) );
        else
            this->CLAM::Enum::LoadFrom( boost::ref(storage) );
    }
    
    
    void default_LoadFrom( ::CLAM::Storage & storage ) {
        CLAM::Enum::LoadFrom( boost::ref(storage) );
    }

    virtual ::CLAM::Component * ShallowCopy(  ) const  {
        if( bp::override func_ShallowCopy = this->get_override( "ShallowCopy" ) )
            return func_ShallowCopy(  );
        else
            return this->CLAM::Enum::ShallowCopy(  );
    }
    
    
    ::CLAM::Component * default_ShallowCopy(  ) const  {
        return CLAM::Enum::ShallowCopy( );
    }

    virtual ::CLAM::Component * Species(  ) const {
        bp::override func_Species = this->get_override( "Species" );
        return func_Species(  );
    }

    virtual void StoreOn( ::CLAM::Storage & storage ) const  {
        if( bp::override func_StoreOn = this->get_override( "StoreOn" ) )
            func_StoreOn( boost::ref(storage) );
        else
            this->CLAM::Enum::StoreOn( boost::ref(storage) );
    }
    
    
    void default_StoreOn( ::CLAM::Storage & storage ) const  {
        CLAM::Enum::StoreOn( boost::ref(storage) );
    }

};

struct Err_wrapper : CLAM::Err, bp::wrapper< CLAM::Err > {

    Err_wrapper( )
    : CLAM::Err( )
      , bp::wrapper< CLAM::Err >(){
        // null constructor
    
    }

    Err_wrapper(char const * msg )
    : CLAM::Err( msg )
      , bp::wrapper< CLAM::Err >(){
        // constructor
    
    }

    Err_wrapper(::CLAM::Err const & arg0 )
    : CLAM::Err( boost::ref(arg0) )
      , bp::wrapper< CLAM::Err >(){
        // copy constructor
    
    }

    virtual char const * what(  ) const   throw(){
        if( bp::override func_what = this->get_override( "what" ) )
            return func_what(  );
        else
            return this->CLAM::Err::what(  );
    }
    
    
    char const * default_what(  ) const   throw(){
        return CLAM::Err::what( );
    }

};

struct FFT_wrapper : CLAM::FFT, bp::wrapper< CLAM::FFT > {

    FFT_wrapper( )
    : CLAM::FFT( )
      , bp::wrapper< CLAM::FFT >(){
        // null constructor
    
    }

    FFT_wrapper(::CLAM::FFTConfig const & config )
    : CLAM::FFT( boost::ref(config) )
      , bp::wrapper< CLAM::FFT >(){
        // constructor
    
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::FFT::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::FFT::GetClassName( );
    }

    bool AbleToExecute(  ) const {
        return CLAM::Processing::AbleToExecute(  );
    }

    void AddConfigErrorMessage( ::std::string const & msg ){
        CLAM::Processing::AddConfigErrorMessage( msg );
    }

    unsigned int BackendBufferSize(  ){
        return CLAM::Processing::BackendBufferSize(  );
    }

    unsigned int BackendSampleRate(  ){
        return CLAM::Processing::BackendSampleRate(  );
    }

    void ChangeSize( int n ){
        CLAM::FFT_base::ChangeSize( n );
    }

    virtual bool ConcreteConfigure( ::CLAM::ProcessingConfig const & arg0 ){
        if( bp::override func_ConcreteConfigure = this->get_override( "ConcreteConfigure" ) )
            return func_ConcreteConfigure( boost::ref(arg0) );
        else
            return this->CLAM::Processing::ConcreteConfigure( boost::ref(arg0) );
    }

    virtual bool ConcreteStart(  ){
        if( bp::override func_ConcreteStart = this->get_override( "ConcreteStart" ) )
            return func_ConcreteStart(  );
        else
            return this->CLAM::Processing::ConcreteStart(  );
    }

    virtual bool ConcreteStop(  ){
        if( bp::override func_ConcreteStop = this->get_override( "ConcreteStop" ) )
            return func_ConcreteStop(  );
        else
            return this->CLAM::Processing::ConcreteStop(  );
    }

    int GetSize(  ){
        return CLAM::FFT_base::GetSize(  );
    }

    void SetExecState( ::CLAM::Processing::ExecState state ){
        CLAM::Processing::SetExecState( state );
    }

};

struct Processing_wrapper : CLAM::Processing, bp::wrapper< CLAM::Processing > {

    Processing_wrapper( )
    : CLAM::Processing( )
      , bp::wrapper< CLAM::Processing >(){
        // null constructor
    
    }

    bool AbleToExecute(  ) const {
        return CLAM::Processing::AbleToExecute(  );
    }

    void AddConfigErrorMessage( ::std::string const & msg ){
        CLAM::Processing::AddConfigErrorMessage( msg );
    }

    unsigned int BackendBufferSize(  ){
        return CLAM::Processing::BackendBufferSize(  );
    }

    unsigned int BackendSampleRate(  ){
        return CLAM::Processing::BackendSampleRate(  );
    }

    virtual bool CanProcessInplace(  ) {
        if( bp::override func_CanProcessInplace = this->get_override( "CanProcessInplace" ) )
            return func_CanProcessInplace(  );
        else
            return this->CLAM::Processing::CanProcessInplace(  );
    }
    
    
    bool default_CanProcessInplace(  ) {
        return CLAM::Processing::CanProcessInplace( );
    }

    virtual bool ConcreteConfigure( ::CLAM::ProcessingConfig const & arg0 ){
        if( bp::override func_ConcreteConfigure = this->get_override( "ConcreteConfigure" ) )
            return func_ConcreteConfigure( boost::ref(arg0) );
        else
            return this->CLAM::Processing::ConcreteConfigure( boost::ref(arg0) );
    }

    virtual bool ConcreteStart(  ){
        if( bp::override func_ConcreteStart = this->get_override( "ConcreteStart" ) )
            return func_ConcreteStart(  );
        else
            return this->CLAM::Processing::ConcreteStart(  );
    }

    virtual bool ConcreteStop(  ){
        if( bp::override func_ConcreteStop = this->get_override( "ConcreteStop" ) )
            return func_ConcreteStop(  );
        else
            return this->CLAM::Processing::ConcreteStop(  );
    }

    virtual bool Do(  ){
        bp::override func_Do = this->get_override( "Do" );
        return func_Do(  );
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

    virtual bool IsSyncSource(  ) const  {
        if( bp::override func_IsSyncSource = this->get_override( "IsSyncSource" ) )
            return func_IsSyncSource(  );
        else
            return this->CLAM::Processing::IsSyncSource(  );
    }
    
    
    bool default_IsSyncSource(  ) const  {
        return CLAM::Processing::IsSyncSource( );
    }

    virtual bool ModifiesPortsAndControlsAtConfiguration(  ) {
        if( bp::override func_ModifiesPortsAndControlsAtConfiguration = this->get_override( "ModifiesPortsAndControlsAtConfiguration" ) )
            return func_ModifiesPortsAndControlsAtConfiguration(  );
        else
            return this->CLAM::Processing::ModifiesPortsAndControlsAtConfiguration(  );
    }
    
    
    bool default_ModifiesPortsAndControlsAtConfiguration(  ) {
        return CLAM::Processing::ModifiesPortsAndControlsAtConfiguration( );
    }

    void SetExecState( ::CLAM::Processing::ExecState state ){
        CLAM::Processing::SetExecState( state );
    }

};

struct FFT_base_wrapper : CLAM::FFT_base, bp::wrapper< CLAM::FFT_base > {

    FFT_base_wrapper( )
    : CLAM::FFT_base( )
      , bp::wrapper< CLAM::FFT_base >(){
        // null constructor
    
    }

    void ChangeSize( int n ){
        CLAM::FFT_base::ChangeSize( n );
    }

    virtual bool ConcreteConfigure( ::CLAM::ProcessingConfig const & arg0 ){
        bp::override func_ConcreteConfigure = this->get_override( "ConcreteConfigure" );
        return func_ConcreteConfigure( boost::ref(arg0) );
    }

    virtual bool DisableExecution(  ) {
        if( bp::override func_DisableExecution = this->get_override( "DisableExecution" ) )
            return func_DisableExecution(  );
        else
            return this->CLAM::FFT_base::DisableExecution(  );
    }
    
    
    bool default_DisableExecution(  ) {
        return CLAM::FFT_base::DisableExecution( );
    }

    virtual bool Do(  ){
        bp::override func_Do = this->get_override( "Do" );
        return func_Do(  );
    }

    virtual bool Do( ::CLAM::Audio const & in, ::CLAM::Spectrum & out ){
        bp::override func_Do = this->get_override( "Do" );
        return func_Do( boost::ref(in), boost::ref(out) );
    }

    virtual bool EnableExecution(  ) {
        if( bp::override func_EnableExecution = this->get_override( "EnableExecution" ) )
            return func_EnableExecution(  );
        else
            return this->CLAM::FFT_base::EnableExecution(  );
    }
    
    
    bool default_EnableExecution(  ) {
        return CLAM::FFT_base::EnableExecution( );
    }

    int GetSize(  ){
        return CLAM::FFT_base::GetSize(  );
    }

    virtual bool MayDisableExecution(  ) const  {
        if( bp::override func_MayDisableExecution = this->get_override( "MayDisableExecution" ) )
            return func_MayDisableExecution(  );
        else
            return this->CLAM::FFT_base::MayDisableExecution(  );
    }
    
    
    bool default_MayDisableExecution(  ) const  {
        return CLAM::FFT_base::MayDisableExecution( );
    }

    virtual void ToComplex( ::CLAM::Spectrum & out ){
        bp::override func_ToComplex = this->get_override( "ToComplex" );
        func_ToComplex( boost::ref(out) );
    }

    virtual void ToOther( ::CLAM::Spectrum & out ) {
        if( bp::override func_ToOther = this->get_override( "ToOther" ) )
            func_ToOther( boost::ref(out) );
        else
            this->CLAM::FFT_base::ToOther( boost::ref(out) );
    }
    
    
    void default_ToOther( ::CLAM::Spectrum & out ) {
        CLAM::FFT_base::ToOther( boost::ref(out) );
    }

    bool AbleToExecute(  ) const {
        return CLAM::Processing::AbleToExecute(  );
    }

    void AddConfigErrorMessage( ::std::string const & msg ){
        CLAM::Processing::AddConfigErrorMessage( msg );
    }

    unsigned int BackendBufferSize(  ){
        return CLAM::Processing::BackendBufferSize(  );
    }

    unsigned int BackendSampleRate(  ){
        return CLAM::Processing::BackendSampleRate(  );
    }

    virtual bool ConcreteStart(  ){
        if( bp::override func_ConcreteStart = this->get_override( "ConcreteStart" ) )
            return func_ConcreteStart(  );
        else
            return this->CLAM::Processing::ConcreteStart(  );
    }

    virtual bool ConcreteStop(  ){
        if( bp::override func_ConcreteStop = this->get_override( "ConcreteStop" ) )
            return func_ConcreteStop(  );
        else
            return this->CLAM::Processing::ConcreteStop(  );
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

    void SetExecState( ::CLAM::Processing::ExecState state ){
        CLAM::Processing::SetExecState( state );
    }

};

struct FFT_ooura_wrapper : CLAM::FFT_ooura, bp::wrapper< CLAM::FFT_ooura > {

    FFT_ooura_wrapper( )
    : CLAM::FFT_ooura( )
      , bp::wrapper< CLAM::FFT_ooura >(){
        // null constructor
    
    }

    FFT_ooura_wrapper(::CLAM::FFTConfig const & c )
    : CLAM::FFT_ooura( boost::ref(c) )
      , bp::wrapper< CLAM::FFT_ooura >(){
        // constructor
    
    }

    virtual bool Do(  ) {
        if( bp::override func_Do = this->get_override( "Do" ) )
            return func_Do(  );
        else
            return this->CLAM::FFT_ooura::Do(  );
    }
    
    
    bool default_Do(  ) {
        return CLAM::FFT_ooura::Do( );
    }

    virtual bool Do( ::CLAM::Audio const & in, ::CLAM::Spectrum & out ) {
        if( bp::override func_Do = this->get_override( "Do" ) )
            return func_Do( boost::ref(in), boost::ref(out) );
        else
            return this->CLAM::FFT_ooura::Do( boost::ref(in), boost::ref(out) );
    }
    
    
    bool default_Do( ::CLAM::Audio const & in, ::CLAM::Spectrum & out ) {
        return CLAM::FFT_ooura::Do( boost::ref(in), boost::ref(out) );
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::FFT_ooura::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::FFT_ooura::GetClassName( );
    }

    virtual bool MayDisableExecution(  ) const  {
        if( bp::override func_MayDisableExecution = this->get_override( "MayDisableExecution" ) )
            return func_MayDisableExecution(  );
        else
            return this->CLAM::FFT_ooura::MayDisableExecution(  );
    }
    
    
    bool default_MayDisableExecution(  ) const  {
        return CLAM::FFT_ooura::MayDisableExecution( );
    }

    bool AbleToExecute(  ) const {
        return CLAM::Processing::AbleToExecute(  );
    }

    void AddConfigErrorMessage( ::std::string const & msg ){
        CLAM::Processing::AddConfigErrorMessage( msg );
    }

    unsigned int BackendBufferSize(  ){
        return CLAM::Processing::BackendBufferSize(  );
    }

    unsigned int BackendSampleRate(  ){
        return CLAM::Processing::BackendSampleRate(  );
    }

    void ChangeSize( int n ){
        CLAM::FFT_base::ChangeSize( n );
    }

    virtual bool ConcreteStart(  ){
        if( bp::override func_ConcreteStart = this->get_override( "ConcreteStart" ) )
            return func_ConcreteStart(  );
        else
            return this->CLAM::Processing::ConcreteStart(  );
    }

    virtual bool ConcreteStop(  ){
        if( bp::override func_ConcreteStop = this->get_override( "ConcreteStop" ) )
            return func_ConcreteStop(  );
        else
            return this->CLAM::Processing::ConcreteStop(  );
    }

    int GetSize(  ){
        return CLAM::FFT_base::GetSize(  );
    }

    void SetExecState( ::CLAM::Processing::ExecState state ){
        CLAM::Processing::SetExecState( state );
    }

};

struct FlagsBase_wrapper : CLAM::FlagsBase, bp::wrapper< CLAM::FlagsBase > {

    FlagsBase_wrapper()
    : CLAM::FlagsBase()
      , bp::wrapper< CLAM::FlagsBase >(){
        // null constructor
        
    }

    virtual unsigned int GetNFlags(  ) const {
        bp::override func_GetNFlags = this->get_override( "GetNFlags" );
        return func_GetNFlags(  );
    }

    virtual bool IsSetFlag( unsigned int whichOne ) const {
        bp::override func_IsSetFlag = this->get_override( "IsSetFlag" );
        return func_IsSetFlag( whichOne );
    }

    virtual void LoadFrom( ::CLAM::Storage & storage ) {
        if( bp::override func_LoadFrom = this->get_override( "LoadFrom" ) )
            func_LoadFrom( boost::ref(storage) );
        else
            this->CLAM::FlagsBase::LoadFrom( boost::ref(storage) );
    }
    
    
    void default_LoadFrom( ::CLAM::Storage & storage ) {
        CLAM::FlagsBase::LoadFrom( boost::ref(storage) );
    }

    virtual void SetFlag( unsigned int whichOne, bool value ){
        bp::override func_SetFlag = this->get_override( "SetFlag" );
        func_SetFlag( whichOne, value );
    }

    virtual void StoreOn( ::CLAM::Storage & storage ) const  {
        if( bp::override func_StoreOn = this->get_override( "StoreOn" ) )
            func_StoreOn( boost::ref(storage) );
        else
            this->CLAM::FlagsBase::StoreOn( boost::ref(storage) );
    }
    
    
    void default_StoreOn( ::CLAM::Storage & storage ) const  {
        CLAM::FlagsBase::StoreOn( boost::ref(storage) );
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

};

struct Flags_less__4u__grate__wrapper : CLAM::Flags< 4u >, bp::wrapper< CLAM::Flags< 4u > > {

    Flags_less__4u__grate__wrapper(::CLAM::FlagsBase::tFlagValue * names )
    : CLAM::Flags<4u>( boost::python::ptr(names) )
      , bp::wrapper< CLAM::Flags< 4u > >(){
        // constructor
    
    }

    Flags_less__4u__grate__wrapper(::CLAM::FlagsBase::tFlagValue * names, ::CLAM::Flags< 4u > const & t )
    : CLAM::Flags<4u>( boost::python::ptr(names), boost::ref(t) )
      , bp::wrapper< CLAM::Flags< 4u > >(){
        // constructor
    
    }

    virtual ::CLAM::Component * DeepCopy(  ) const  {
        if( bp::override func_DeepCopy = this->get_override( "DeepCopy" ) )
            return func_DeepCopy(  );
        else
            return this->CLAM::Flags< 4u >::DeepCopy(  );
    }
    
    
    ::CLAM::Component * default_DeepCopy(  ) const  {
        return CLAM::Flags< 4u >::DeepCopy( );
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::Flags< 4u >::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::Flags< 4u >::GetClassName( );
    }

    virtual unsigned int GetNFlags(  ) const  {
        if( bp::override func_GetNFlags = this->get_override( "GetNFlags" ) )
            return func_GetNFlags(  );
        else
            return this->CLAM::Flags< 4u >::GetNFlags(  );
    }
    
    
    unsigned int default_GetNFlags(  ) const  {
        return CLAM::Flags< 4u >::GetNFlags( );
    }

    virtual bool IsSetFlag( unsigned int whichOne ) const {
        if( bp::override func_IsSetFlag = this->get_override( "IsSetFlag" ) )
            return func_IsSetFlag( whichOne );
        else
            return this->CLAM::Flags< 4u >::IsSetFlag( whichOne );
    }

    virtual void SetFlag( unsigned int whichOne, bool value=true ){
        if( bp::override func_SetFlag = this->get_override( "SetFlag" ) )
            func_SetFlag( whichOne, value );
        else
            this->CLAM::Flags< 4u >::SetFlag( whichOne, value );
    }

    virtual ::CLAM::Component * ShallowCopy(  ) const  {
        if( bp::override func_ShallowCopy = this->get_override( "ShallowCopy" ) )
            return func_ShallowCopy(  );
        else
            return this->CLAM::Flags< 4u >::ShallowCopy(  );
    }
    
    
    ::CLAM::Component * default_ShallowCopy(  ) const  {
        return CLAM::Flags< 4u >::ShallowCopy( );
    }

    virtual ::CLAM::Component * Species(  ) const {
        bp::override func_Species = this->get_override( "Species" );
        return func_Species(  );
    }

};

struct FlattenedNetwork_wrapper : CLAM::FlattenedNetwork, bp::wrapper< CLAM::FlattenedNetwork > {

    FlattenedNetwork_wrapper(CLAM::FlattenedNetwork const & arg )
    : CLAM::FlattenedNetwork( arg )
      , bp::wrapper< CLAM::FlattenedNetwork >(){
        // copy constructor
        
    }

    FlattenedNetwork_wrapper( )
    : CLAM::FlattenedNetwork( )
      , bp::wrapper< CLAM::FlattenedNetwork >(){
        // null constructor
    
    }

    virtual void AddProcessing( ::std::string const & arg0, ::CLAM::Processing * arg1 ) {
        if( bp::override func_AddProcessing = this->get_override( "AddProcessing" ) )
            func_AddProcessing( arg0, boost::python::ptr(arg1) );
        else
            this->CLAM::FlattenedNetwork::AddProcessing( arg0, boost::python::ptr(arg1) );
    }
    
    
    void default_AddProcessing( ::std::string const & arg0, ::CLAM::Processing * arg1 ) {
        CLAM::FlattenedNetwork::AddProcessing( arg0, boost::python::ptr(arg1) );
    }

    virtual void AddProcessing( ::std::string const & name, ::std::string const & key ) {
        if( bp::override func_AddProcessing = this->get_override( "AddProcessing" ) )
            func_AddProcessing( name, key );
        else
            this->CLAM::FlattenedNetwork::AddProcessing( name, key );
    }
    
    
    void default_AddProcessing( ::std::string const & name, ::std::string const & key ) {
        CLAM::FlattenedNetwork::AddProcessing( name, key );
    }

    virtual ::std::string AddProcessing( ::std::string const & key ) {
        if( bp::override func_AddProcessing = this->get_override( "AddProcessing" ) )
            return func_AddProcessing( key );
        else
            return this->CLAM::FlattenedNetwork::AddProcessing( key );
    }
    
    
    ::std::string default_AddProcessing( ::std::string const & key ) {
        return CLAM::FlattenedNetwork::AddProcessing( key );
    }

    virtual unsigned int BackendBufferSize(  ) {
        if( bp::override func_BackendBufferSize = this->get_override( "BackendBufferSize" ) )
            return func_BackendBufferSize(  );
        else
            return this->CLAM::FlattenedNetwork::BackendBufferSize(  );
    }
    
    
    unsigned int default_BackendBufferSize(  ) {
        return CLAM::FlattenedNetwork::BackendBufferSize( );
    }

    virtual unsigned int BackendSampleRate(  ) {
        if( bp::override func_BackendSampleRate = this->get_override( "BackendSampleRate" ) )
            return func_BackendSampleRate(  );
        else
            return this->CLAM::FlattenedNetwork::BackendSampleRate(  );
    }
    
    
    unsigned int default_BackendSampleRate(  ) {
        return CLAM::FlattenedNetwork::BackendSampleRate( );
    }

    virtual ::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > BeginProcessings(  ) {
        if( bp::override func_BeginProcessings = this->get_override( "BeginProcessings" ) )
            return func_BeginProcessings(  );
        else
            return this->CLAM::FlattenedNetwork::BeginProcessings(  );
    }
    
    
    ::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > default_BeginProcessings(  ) {
        return CLAM::FlattenedNetwork::BeginProcessings( );
    }

    virtual ::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > BeginProcessings(  ) const  {
        if( bp::override func_BeginProcessings = this->get_override( "BeginProcessings" ) )
            return func_BeginProcessings(  );
        else
            return this->CLAM::FlattenedNetwork::BeginProcessings(  );
    }
    
    
    ::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > default_BeginProcessings(  ) const  {
        return CLAM::FlattenedNetwork::BeginProcessings( );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else
            this->CLAM::FlattenedNetwork::Clear(  );
    }
    
    
    void default_Clear(  ) {
        CLAM::FlattenedNetwork::Clear( );
    }

    virtual bool ConfigureProcessing( ::std::string const & arg0, ::CLAM::ProcessingConfig const & arg1 ) {
        if( bp::override func_ConfigureProcessing = this->get_override( "ConfigureProcessing" ) )
            return func_ConfigureProcessing( arg0, boost::ref(arg1) );
        else
            return this->CLAM::FlattenedNetwork::ConfigureProcessing( arg0, boost::ref(arg1) );
    }
    
    
    bool default_ConfigureProcessing( ::std::string const & arg0, ::CLAM::ProcessingConfig const & arg1 ) {
        return CLAM::FlattenedNetwork::ConfigureProcessing( arg0, boost::ref(arg1) );
    }

    virtual bool ConnectControls( ::std::string const & arg0, ::std::string const & arg1 ) {
        if( bp::override func_ConnectControls = this->get_override( "ConnectControls" ) )
            return func_ConnectControls( arg0, arg1 );
        else
            return this->CLAM::FlattenedNetwork::ConnectControls( arg0, arg1 );
    }
    
    
    bool default_ConnectControls( ::std::string const & arg0, ::std::string const & arg1 ) {
        return CLAM::FlattenedNetwork::ConnectControls( arg0, arg1 );
    }

    virtual bool ConnectPorts( ::std::string const & arg0, ::std::string const & arg1 ) {
        if( bp::override func_ConnectPorts = this->get_override( "ConnectPorts" ) )
            return func_ConnectPorts( arg0, arg1 );
        else
            return this->CLAM::FlattenedNetwork::ConnectPorts( arg0, arg1 );
    }
    
    
    bool default_ConnectPorts( ::std::string const & arg0, ::std::string const & arg1 ) {
        return CLAM::FlattenedNetwork::ConnectPorts( arg0, arg1 );
    }

    virtual bool DisconnectControls( ::std::string const & arg0, ::std::string const & arg1 ) {
        if( bp::override func_DisconnectControls = this->get_override( "DisconnectControls" ) )
            return func_DisconnectControls( arg0, arg1 );
        else
            return this->CLAM::FlattenedNetwork::DisconnectControls( arg0, arg1 );
    }
    
    
    bool default_DisconnectControls( ::std::string const & arg0, ::std::string const & arg1 ) {
        return CLAM::FlattenedNetwork::DisconnectControls( arg0, arg1 );
    }

    virtual bool DisconnectPorts( ::std::string const & arg0, ::std::string const & arg1 ) {
        if( bp::override func_DisconnectPorts = this->get_override( "DisconnectPorts" ) )
            return func_DisconnectPorts( arg0, arg1 );
        else
            return this->CLAM::FlattenedNetwork::DisconnectPorts( arg0, arg1 );
    }
    
    
    bool default_DisconnectPorts( ::std::string const & arg0, ::std::string const & arg1 ) {
        return CLAM::FlattenedNetwork::DisconnectPorts( arg0, arg1 );
    }

    virtual ::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > EndProcessings(  ) {
        if( bp::override func_EndProcessings = this->get_override( "EndProcessings" ) )
            return func_EndProcessings(  );
        else
            return this->CLAM::FlattenedNetwork::EndProcessings(  );
    }
    
    
    ::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > default_EndProcessings(  ) {
        return CLAM::FlattenedNetwork::EndProcessings( );
    }

    virtual ::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > EndProcessings(  ) const  {
        if( bp::override func_EndProcessings = this->get_override( "EndProcessings" ) )
            return func_EndProcessings(  );
        else
            return this->CLAM::FlattenedNetwork::EndProcessings(  );
    }
    
    
    ::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > default_EndProcessings(  ) const  {
        return CLAM::FlattenedNetwork::EndProcessings( );
    }

    virtual ::std::map< std::string, CLAM::BaseNetwork::Geometry > const GetAndClearGeometries(  ) {
        if( bp::override func_GetAndClearGeometries = this->get_override( "GetAndClearGeometries" ) )
            return func_GetAndClearGeometries(  );
        else
            return this->CLAM::FlattenedNetwork::GetAndClearGeometries(  );
    }
    
    
    ::std::map< std::string, CLAM::BaseNetwork::Geometry > const default_GetAndClearGeometries(  ) {
        return CLAM::FlattenedNetwork::GetAndClearGeometries( );
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::FlattenedNetwork::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::FlattenedNetwork::GetClassName( );
    }

    virtual ::std::string GetConfigurationErrors(  ) const  {
        if( bp::override func_GetConfigurationErrors = this->get_override( "GetConfigurationErrors" ) )
            return func_GetConfigurationErrors(  );
        else
            return this->CLAM::FlattenedNetwork::GetConfigurationErrors(  );
    }
    
    
    ::std::string default_GetConfigurationErrors(  ) const  {
        return CLAM::FlattenedNetwork::GetConfigurationErrors( );
    }

    virtual ::std::string GetConnectorIdentifier( ::std::string const & arg0 ) const  {
        if( bp::override func_GetConnectorIdentifier = this->get_override( "GetConnectorIdentifier" ) )
            return func_GetConnectorIdentifier( arg0 );
        else
            return this->CLAM::FlattenedNetwork::GetConnectorIdentifier( arg0 );
    }
    
    
    ::std::string default_GetConnectorIdentifier( ::std::string const & arg0 ) const  {
        return CLAM::FlattenedNetwork::GetConnectorIdentifier( arg0 );
    }

    virtual ::std::list< std::string > GetInControlsConnectedTo( ::std::string const & arg0 ) const  {
        if( bp::override func_GetInControlsConnectedTo = this->get_override( "GetInControlsConnectedTo" ) )
            return func_GetInControlsConnectedTo( arg0 );
        else
            return this->CLAM::FlattenedNetwork::GetInControlsConnectedTo( arg0 );
    }
    
    
    ::std::list< std::string > default_GetInControlsConnectedTo( ::std::string const & arg0 ) const  {
        return CLAM::FlattenedNetwork::GetInControlsConnectedTo( arg0 );
    }

    virtual ::std::list< std::string > GetInPortsConnectedTo( ::std::string const & arg0 ) const  {
        if( bp::override func_GetInPortsConnectedTo = this->get_override( "GetInPortsConnectedTo" ) )
            return func_GetInPortsConnectedTo( arg0 );
        else
            return this->CLAM::FlattenedNetwork::GetInPortsConnectedTo( arg0 );
    }
    
    
    ::std::list< std::string > default_GetInPortsConnectedTo( ::std::string const & arg0 ) const  {
        return CLAM::FlattenedNetwork::GetInPortsConnectedTo( arg0 );
    }

    virtual ::std::list< CLAM::InPortBase* > GetInPortsConnectedTo( ::CLAM::OutPortBase & arg0 ) const  {
        if( bp::override func_GetInPortsConnectedTo = this->get_override( "GetInPortsConnectedTo" ) )
            return func_GetInPortsConnectedTo( boost::ref(arg0) );
        else
            return this->CLAM::FlattenedNetwork::GetInPortsConnectedTo( boost::ref(arg0) );
    }
    
    
    ::std::list< CLAM::InPortBase* > default_GetInPortsConnectedTo( ::CLAM::OutPortBase & arg0 ) const  {
        return CLAM::FlattenedNetwork::GetInPortsConnectedTo( boost::ref(arg0) );
    }

    virtual ::std::string GetProcessingIdentifier( ::std::string const & arg0 ) const  {
        if( bp::override func_GetProcessingIdentifier = this->get_override( "GetProcessingIdentifier" ) )
            return func_GetProcessingIdentifier( arg0 );
        else
            return this->CLAM::FlattenedNetwork::GetProcessingIdentifier( arg0 );
    }
    
    
    ::std::string default_GetProcessingIdentifier( ::std::string const & arg0 ) const  {
        return CLAM::FlattenedNetwork::GetProcessingIdentifier( arg0 );
    }

    virtual ::std::string GetUnconnectedInPorts(  ) const  {
        if( bp::override func_GetUnconnectedInPorts = this->get_override( "GetUnconnectedInPorts" ) )
            return func_GetUnconnectedInPorts(  );
        else
            return this->CLAM::FlattenedNetwork::GetUnconnectedInPorts(  );
    }
    
    
    ::std::string default_GetUnconnectedInPorts(  ) const  {
        return CLAM::FlattenedNetwork::GetUnconnectedInPorts( );
    }

    virtual ::std::string GetUnusedName( ::std::string const & prefix ) const  {
        if( bp::override func_GetUnusedName = this->get_override( "GetUnusedName" ) )
            return func_GetUnusedName( prefix );
        else
            return this->CLAM::FlattenedNetwork::GetUnusedName( prefix );
    }
    
    
    ::std::string default_GetUnusedName( ::std::string const & prefix ) const  {
        return CLAM::FlattenedNetwork::GetUnusedName( prefix );
    }

    virtual bool HasMisconfiguredProcessings(  ) const  {
        if( bp::override func_HasMisconfiguredProcessings = this->get_override( "HasMisconfiguredProcessings" ) )
            return func_HasMisconfiguredProcessings(  );
        else
            return this->CLAM::FlattenedNetwork::HasMisconfiguredProcessings(  );
    }
    
    
    bool default_HasMisconfiguredProcessings(  ) const  {
        return CLAM::FlattenedNetwork::HasMisconfiguredProcessings( );
    }

    virtual bool HasProcessing( ::std::string const & name ) const  {
        if( bp::override func_HasProcessing = this->get_override( "HasProcessing" ) )
            return func_HasProcessing( name );
        else
            return this->CLAM::FlattenedNetwork::HasProcessing( name );
    }
    
    
    bool default_HasProcessing( ::std::string const & name ) const  {
        return CLAM::FlattenedNetwork::HasProcessing( name );
    }

    virtual bool HasSyncSource(  ) const  {
        if( bp::override func_HasSyncSource = this->get_override( "HasSyncSource" ) )
            return func_HasSyncSource(  );
        else
            return this->CLAM::FlattenedNetwork::HasSyncSource(  );
    }
    
    
    bool default_HasSyncSource(  ) const  {
        return CLAM::FlattenedNetwork::HasSyncSource( );
    }

    virtual bool HasUnconnectedInPorts(  ) const  {
        if( bp::override func_HasUnconnectedInPorts = this->get_override( "HasUnconnectedInPorts" ) )
            return func_HasUnconnectedInPorts(  );
        else
            return this->CLAM::FlattenedNetwork::HasUnconnectedInPorts(  );
    }
    
    
    bool default_HasUnconnectedInPorts(  ) const  {
        return CLAM::FlattenedNetwork::HasUnconnectedInPorts( );
    }

    virtual bool IsEmpty(  ) const  {
        if( bp::override func_IsEmpty = this->get_override( "IsEmpty" ) )
            return func_IsEmpty(  );
        else
            return this->CLAM::FlattenedNetwork::IsEmpty(  );
    }
    
    
    bool default_IsEmpty(  ) const  {
        return CLAM::FlattenedNetwork::IsEmpty( );
    }

    virtual bool IsReady(  ) const  {
        if( bp::override func_IsReady = this->get_override( "IsReady" ) )
            return func_IsReady(  );
        else
            return this->CLAM::FlattenedNetwork::IsReady(  );
    }
    
    
    bool default_IsReady(  ) const  {
        return CLAM::FlattenedNetwork::IsReady( );
    }

    virtual void LoadFrom( ::CLAM::Storage & storage ) {
        if( bp::override func_LoadFrom = this->get_override( "LoadFrom" ) )
            func_LoadFrom( boost::ref(storage) );
        else
            this->CLAM::FlattenedNetwork::LoadFrom( boost::ref(storage) );
    }
    
    
    void default_LoadFrom( ::CLAM::Storage & storage ) {
        CLAM::FlattenedNetwork::LoadFrom( boost::ref(storage) );
    }

    virtual void ReconfigureAllProcessings(  ) {
        if( bp::override func_ReconfigureAllProcessings = this->get_override( "ReconfigureAllProcessings" ) )
            func_ReconfigureAllProcessings(  );
        else
            this->CLAM::FlattenedNetwork::ReconfigureAllProcessings(  );
    }
    
    
    void default_ReconfigureAllProcessings(  ) {
        CLAM::FlattenedNetwork::ReconfigureAllProcessings( );
    }

    virtual void RemoveProcessing( ::std::string const & arg0 ) {
        if( bp::override func_RemoveProcessing = this->get_override( "RemoveProcessing" ) )
            func_RemoveProcessing( arg0 );
        else
            this->CLAM::FlattenedNetwork::RemoveProcessing( arg0 );
    }
    
    
    void default_RemoveProcessing( ::std::string const & arg0 ) {
        CLAM::FlattenedNetwork::RemoveProcessing( arg0 );
    }

    virtual bool RenameProcessing( ::std::string const & oldName, ::std::string const & newName ) {
        if( bp::override func_RenameProcessing = this->get_override( "RenameProcessing" ) )
            return func_RenameProcessing( oldName, newName );
        else
            return this->CLAM::FlattenedNetwork::RenameProcessing( oldName, newName );
    }
    
    
    bool default_RenameProcessing( ::std::string const & oldName, ::std::string const & newName ) {
        return CLAM::FlattenedNetwork::RenameProcessing( oldName, newName );
    }

    virtual void SetName( ::std::string const & name ) {
        if( bp::override func_SetName = this->get_override( "SetName" ) )
            func_SetName( name );
        else
            this->CLAM::FlattenedNetwork::SetName( name );
    }
    
    
    void default_SetName( ::std::string const & name ) {
        CLAM::FlattenedNetwork::SetName( name );
    }

    virtual bool SetProcessingsGeometries( ::std::map< std::string, CLAM::BaseNetwork::Geometry > const & processingsGeometries ) {
        if( bp::override func_SetProcessingsGeometries = this->get_override( "SetProcessingsGeometries" ) )
            return func_SetProcessingsGeometries( boost::ref(processingsGeometries) );
        else
            return this->CLAM::FlattenedNetwork::SetProcessingsGeometries( boost::ref(processingsGeometries) );
    }
    
    
    bool default_SetProcessingsGeometries( ::std::map< std::string, CLAM::BaseNetwork::Geometry > const & processingsGeometries ) {
        return CLAM::FlattenedNetwork::SetProcessingsGeometries( boost::ref(processingsGeometries) );
    }

    virtual void StoreOn( ::CLAM::Storage & storage ) const  {
        if( bp::override func_StoreOn = this->get_override( "StoreOn" ) )
            func_StoreOn( boost::ref(storage) );
        else
            this->CLAM::FlattenedNetwork::StoreOn( boost::ref(storage) );
    }
    
    
    void default_StoreOn( ::CLAM::Storage & storage ) const  {
        CLAM::FlattenedNetwork::StoreOn( boost::ref(storage) );
    }

    virtual bool UpdateSelections( ::std::list< std::string > const & processingsNamesList ) {
        if( bp::override func_UpdateSelections = this->get_override( "UpdateSelections" ) )
            return func_UpdateSelections( boost::ref(processingsNamesList) );
        else
            return this->CLAM::FlattenedNetwork::UpdateSelections( boost::ref(processingsNamesList) );
    }
    
    
    bool default_UpdateSelections( ::std::list< std::string > const & processingsNamesList ) {
        return CLAM::FlattenedNetwork::UpdateSelections( boost::ref(processingsNamesList) );
    }

    virtual void setPasteMode(  ) {
        if( bp::override func_setPasteMode = this->get_override( "setPasteMode" ) )
            func_setPasteMode(  );
        else
            this->CLAM::FlattenedNetwork::setPasteMode(  );
    }
    
    
    void default_setPasteMode(  ) {
        CLAM::FlattenedNetwork::setPasteMode( );
    }

};

struct FlowControl_wrapper : CLAM::FlowControl, bp::wrapper< CLAM::FlowControl > {

    FlowControl_wrapper( )
    : CLAM::FlowControl( )
      , bp::wrapper< CLAM::FlowControl >(){
        // null constructor
    
    }

    virtual void AttachToNetwork( ::CLAM::Network * arg0 ) {
        if( bp::override func_AttachToNetwork = this->get_override( "AttachToNetwork" ) )
            func_AttachToNetwork( boost::python::ptr(arg0) );
        else
            this->CLAM::FlowControl::AttachToNetwork( boost::python::ptr(arg0) );
    }
    
    
    void default_AttachToNetwork( ::CLAM::Network * arg0 ) {
        CLAM::FlowControl::AttachToNetwork( boost::python::ptr(arg0) );
    }

    virtual void Do(  ){
        bp::override func_Do = this->get_override( "Do" );
        func_Do(  );
    }

    bool HasNetworkTopologyChanged(  ) const {
        return CLAM::FlowControl::HasNetworkTopologyChanged(  );
    }

    virtual void ProcessingAddedToNetwork( ::CLAM::Processing & added ) {
        if( bp::override func_ProcessingAddedToNetwork = this->get_override( "ProcessingAddedToNetwork" ) )
            func_ProcessingAddedToNetwork( boost::ref(added) );
        else
            this->CLAM::FlowControl::ProcessingAddedToNetwork( boost::ref(added) );
    }
    
    
    void default_ProcessingAddedToNetwork( ::CLAM::Processing & added ) {
        CLAM::FlowControl::ProcessingAddedToNetwork( boost::ref(added) );
    }

    virtual void ProcessingRemovedFromNetwork( ::CLAM::Processing & removed ) {
        if( bp::override func_ProcessingRemovedFromNetwork = this->get_override( "ProcessingRemovedFromNetwork" ) )
            func_ProcessingRemovedFromNetwork( boost::ref(removed) );
        else
            this->CLAM::FlowControl::ProcessingRemovedFromNetwork( boost::ref(removed) );
    }
    
    
    void default_ProcessingRemovedFromNetwork( ::CLAM::Processing & removed ) {
        CLAM::FlowControl::ProcessingRemovedFromNetwork( boost::ref(removed) );
    }

};

struct InControl_wrapper : CLAM::InControl, bp::wrapper< CLAM::InControl > {

    InControl_wrapper(CLAM::InControl const & arg )
    : CLAM::InControl( arg )
      , bp::wrapper< CLAM::InControl >(){
        // copy constructor
        
    }

    InControl_wrapper(::std::string const & name, ::CLAM::Processing * parent=0, bool const publish=true )
    : CLAM::InControl( name, boost::python::ptr(parent), publish )
      , bp::wrapper< CLAM::InControl >(){
        // constructor
    
    }

    virtual int DoControl( ::CLAM::TControlData val ) {
        if( bp::override func_DoControl = this->get_override( "DoControl" ) )
            return func_DoControl( val );
        else
            return this->CLAM::InControl::DoControl( val );
    }
    
    
    int default_DoControl( ::CLAM::TControlData val ) {
        return CLAM::InControl::DoControl( val );
    }

};

struct NetworkPlayer_wrapper : CLAM::NetworkPlayer, bp::wrapper< CLAM::NetworkPlayer > {

    NetworkPlayer_wrapper( )
    : CLAM::NetworkPlayer( )
      , bp::wrapper< CLAM::NetworkPlayer >(){
        // null constructor
    
    }

    virtual unsigned int BackendBufferSize(  ) {
        if( bp::override func_BackendBufferSize = this->get_override( "BackendBufferSize" ) )
            return func_BackendBufferSize(  );
        else
            return this->CLAM::NetworkPlayer::BackendBufferSize(  );
    }
    
    
    unsigned int default_BackendBufferSize(  ) {
        return CLAM::NetworkPlayer::BackendBufferSize( );
    }

    virtual unsigned int BackendSampleRate(  ) {
        if( bp::override func_BackendSampleRate = this->get_override( "BackendSampleRate" ) )
            return func_BackendSampleRate(  );
        else
            return this->CLAM::NetworkPlayer::BackendSampleRate(  );
    }
    
    
    unsigned int default_BackendSampleRate(  ) {
        return CLAM::NetworkPlayer::BackendSampleRate( );
    }

    void CollectSourcesAndSinks(  ){
        CLAM::NetworkPlayer::CollectSourcesAndSinks(  );
    }

    ::std::vector< CLAM::AudioSink* > const & GetAudioSinks(  ) const {
        return CLAM::NetworkPlayer::GetAudioSinks(  );
    }

    ::std::vector< CLAM::AudioSink* > & GetAudioSinks(  ){
        return CLAM::NetworkPlayer::GetAudioSinks(  );
    }

    ::std::vector< CLAM::AudioSource* > const & GetAudioSources(  ) const {
        return CLAM::NetworkPlayer::GetAudioSources(  );
    }

    ::std::vector< CLAM::AudioSource* > & GetAudioSources(  ){
        return CLAM::NetworkPlayer::GetAudioSources(  );
    }

    ::CLAM::Network & GetNetwork(  ){
        return CLAM::NetworkPlayer::GetNetwork(  );
    }

    virtual void Init(  ) {
        if( bp::override func_Init = this->get_override( "Init" ) )
            func_Init(  );
        else
            this->CLAM::NetworkPlayer::Init(  );
    }
    
    
    void default_Init(  ) {
        CLAM::NetworkPlayer::Init( );
    }

    virtual bool IsWorking(  ) const {
        bp::override func_IsWorking = this->get_override( "IsWorking" );
        return func_IsWorking(  );
    }

    virtual ::std::string NonWorkingReason(  ) const {
        bp::override func_NonWorkingReason = this->get_override( "NonWorkingReason" );
        return func_NonWorkingReason(  );
    }

    void SetStopped( bool const val ){
        CLAM::NetworkPlayer::SetStopped( val );
    }

    virtual void Start(  ){
        bp::override func_Start = this->get_override( "Start" );
        func_Start(  );
    }

    virtual void Stop(  ){
        bp::override func_Stop = this->get_override( "Stop" );
        func_Stop(  );
    }

};

struct OutControl_wrapper : CLAM::OutControl, bp::wrapper< CLAM::OutControl > {

    OutControl_wrapper(CLAM::OutControl const & arg )
    : CLAM::OutControl( arg )
      , bp::wrapper< CLAM::OutControl >(){
        // copy constructor
        
    }

    OutControl_wrapper(::std::string const & name, ::CLAM::Processing * parent=0, bool const publish=true )
    : CLAM::OutControl( name, boost::python::ptr(parent), publish )
      , bp::wrapper< CLAM::OutControl >(){
        // constructor
    
    }

    virtual void AddLink( ::CLAM::InControl & in ) {
        if( bp::override func_AddLink = this->get_override( "AddLink" ) )
            func_AddLink( boost::ref(in) );
        else
            this->CLAM::OutControl::AddLink( boost::ref(in) );
    }
    
    
    void default_AddLink( ::CLAM::InControl & in ) {
        CLAM::OutControl::AddLink( boost::ref(in) );
    }

};

struct ProcessingConfig_wrapper : CLAM::ProcessingConfig, bp::wrapper< CLAM::ProcessingConfig > {

    ProcessingConfig_wrapper(int const n )
    : CLAM::ProcessingConfig( n )
      , bp::wrapper< CLAM::ProcessingConfig >(){
        // constructor
    
    }

    ProcessingConfig_wrapper(::CLAM::ProcessingConfig const & prototype, bool shareData=false, bool deep=true )
    : CLAM::ProcessingConfig( boost::ref(prototype), shareData, deep )
      , bp::wrapper< CLAM::ProcessingConfig >(){
        // constructor
    
    }

    virtual char const * GetClassName(  ) const  {
        if( bp::override func_GetClassName = this->get_override( "GetClassName" ) )
            return func_GetClassName(  );
        else
            return this->CLAM::ProcessingConfig::GetClassName(  );
    }
    
    
    char const * default_GetClassName(  ) const  {
        return CLAM::ProcessingConfig::GetClassName( );
    }

    virtual ::CLAM::DynamicType & GetDynamicTypeCopy( bool const shareData=false, bool const deep=false ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual ::std::type_info const & GetTypeId( unsigned int i ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual void LoadDynAttributes( ::CLAM::Storage & s ){
        bp::override func_LoadDynAttributes = this->get_override( "LoadDynAttributes" );
        func_LoadDynAttributes( boost::ref(s) );
    }

    virtual void StoreDynAttributes( ::CLAM::Storage & s ) const {
        bp::override func_StoreDynAttributes = this->get_override( "StoreDynAttributes" );
        func_StoreDynAttributes( boost::ref(s) );
    }

};

struct ProcessingData_wrapper : CLAM::ProcessingData, bp::wrapper< CLAM::ProcessingData > {

    ProcessingData_wrapper(int const n )
    : CLAM::ProcessingData( n )
      , bp::wrapper< CLAM::ProcessingData >(){
        // constructor
    
    }

    ProcessingData_wrapper(::CLAM::ProcessingData const & prototype, bool shareData=false, bool deep=true )
    : CLAM::ProcessingData( boost::ref(prototype), shareData, deep )
      , bp::wrapper< CLAM::ProcessingData >(){
        // constructor
    
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

    virtual ::CLAM::DynamicType & GetDynamicTypeCopy( bool const shareData=false, bool const deep=false ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual ::std::type_info const & GetTypeId( unsigned int i ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual void LoadDynAttributes( ::CLAM::Storage & s ){
        bp::override func_LoadDynAttributes = this->get_override( "LoadDynAttributes" );
        func_LoadDynAttributes( boost::ref(s) );
    }

    virtual void StoreDynAttributes( ::CLAM::Storage & s ) const {
        bp::override func_StoreDynAttributes = this->get_override( "StoreDynAttributes" );
        func_StoreDynAttributes( boost::ref(s) );
    }

};

struct ProcessingDataConfig_wrapper : CLAM::ProcessingDataConfig, bp::wrapper< CLAM::ProcessingDataConfig > {

    ProcessingDataConfig_wrapper(int const n )
    : CLAM::ProcessingDataConfig( n )
      , bp::wrapper< CLAM::ProcessingDataConfig >(){
        // constructor
    
    }

    ProcessingDataConfig_wrapper(::CLAM::ProcessingDataConfig const & prototype, bool shareData=false, bool deep=true )
    : CLAM::ProcessingDataConfig( boost::ref(prototype), shareData, deep )
      , bp::wrapper< CLAM::ProcessingDataConfig >(){
        // constructor
    
    }

    virtual char const * GetClassName(  ) const {
        bp::override func_GetClassName = this->get_override( "GetClassName" );
        return func_GetClassName(  );
    }

    virtual ::CLAM::DynamicType & GetDynamicTypeCopy( bool const shareData=false, bool const deep=false ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual ::std::type_info const & GetTypeId( unsigned int i ) const {
        throw std::logic_error("warning W1049: This method could not be overriden in Python - method returns reference to local variable!");
    }

    virtual void LoadDynAttributes( ::CLAM::Storage & s ){
        bp::override func_LoadDynAttributes = this->get_override( "LoadDynAttributes" );
        func_LoadDynAttributes( boost::ref(s) );
    }

    virtual void StoreDynAttributes( ::CLAM::Storage & s ) const {
        bp::override func_StoreDynAttributes = this->get_override( "StoreDynAttributes" );
        func_StoreDynAttributes( boost::ref(s) );
    }

};

struct SpecTypeFlags_wrapper : CLAM::SpecTypeFlags, bp::wrapper< CLAM::SpecTypeFlags > {

    SpecTypeFlags_wrapper( )
    : CLAM::SpecTypeFlags( )
      , bp::wrapper< CLAM::SpecTypeFlags >(){
        // null constructor
    
    }

    SpecTypeFlags_wrapper(::CLAM::SpecTypeFlags const & t )
    : CLAM::SpecTypeFlags( boost::ref(t) )
      , bp::wrapper< CLAM::SpecTypeFlags >(){
        // copy constructor
    
    }

    virtual ::CLAM::Component * Species(  ) const  {
        if( bp::override func_Species = this->get_override( "Species" ) )
            return func_Species(  );
        else
            return this->CLAM::SpecTypeFlags::Species(  );
    }
    
    
    ::CLAM::Component * default_Species(  ) const  {
        return CLAM::SpecTypeFlags::Species( );
    }

    virtual bool IsSetFlag( unsigned int whichOne ) const {
        if( bp::override func_IsSetFlag = this->get_override( "IsSetFlag" ) )
            return func_IsSetFlag( whichOne );
        else
            return this->CLAM::Flags< 4u >::IsSetFlag( whichOne );
    }

    virtual void SetFlag( unsigned int whichOne, bool value=true ){
        if( bp::override func_SetFlag = this->get_override( "SetFlag" ) )
            func_SetFlag( whichOne, value );
        else
            this->CLAM::Flags< 4u >::SetFlag( whichOne, value );
    }

};

struct Storage_wrapper : CLAM::Storage, bp::wrapper< CLAM::Storage > {

    Storage_wrapper()
    : CLAM::Storage()
      , bp::wrapper< CLAM::Storage >(){
        // null constructor
        
    }

    virtual bool Load( ::CLAM::Storable & object ){
        bp::override func_Load = this->get_override( "Load" );
        return func_Load( boost::ref(object) );
    }

    virtual void Store( ::CLAM::Storable const & object ){
        bp::override func_Store = this->get_override( "Store" );
        func_Store( boost::ref(object) );
    }

};

struct XmlStorage_wrapper : CLAM::XmlStorage, bp::wrapper< CLAM::XmlStorage > {

    XmlStorage_wrapper(CLAM::XmlStorage const & arg )
    : CLAM::XmlStorage( arg )
      , bp::wrapper< CLAM::XmlStorage >(){
        // copy constructor
        
    }

    XmlStorage_wrapper( )
    : CLAM::XmlStorage( )
      , bp::wrapper< CLAM::XmlStorage >(){
        // null constructor
    
    }

    virtual bool Load( ::CLAM::Storable & storable ) {
        if( bp::override func_Load = this->get_override( "Load" ) )
            return func_Load( boost::ref(storable) );
        else
            return this->CLAM::XmlStorage::Load( boost::ref(storable) );
    }
    
    
    bool default_Load( ::CLAM::Storable & storable ) {
        return CLAM::XmlStorage::Load( boost::ref(storable) );
    }

    virtual void Store( ::CLAM::Storable const & storable ) {
        if( bp::override func_Store = this->get_override( "Store" ) )
            func_Store( boost::ref(storable) );
        else
            this->CLAM::XmlStorage::Store( boost::ref(storable) );
    }
    
    
    void default_Store( ::CLAM::Storable const & storable ) {
        CLAM::XmlStorage::Store( boost::ref(storable) );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< std::basic_string< char, std::char_traits< char >, std::allocator< char > > >{

    static bool const equality_comparable = true;
    typedef std::equal_to< std::basic_string< char, std::char_traits< char >, std::allocator< char > > > equal_to;

    static bool const less_than_comparable = true;
    typedef std::less< std::basic_string< char, std::char_traits< char >, std::allocator< char > > > less;

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< CLAM::BaseNetwork::Geometry >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(clam){
    { //::std::vector< CLAM::AudioSource* >
        typedef bp::class_< std::vector< CLAM::AudioSource* > > AudioSources_exposer_t;
        AudioSources_exposer_t AudioSources_exposer = AudioSources_exposer_t( "AudioSources" );
        bp::scope AudioSources_scope( AudioSources_exposer );
        AudioSources_exposer.def( bp::indexing::vector_suite< std::vector< CLAM::AudioSource* > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< CLAM::AudioSink* >
        typedef bp::class_< std::vector< CLAM::AudioSink* > > AudioSinks_exposer_t;
        AudioSinks_exposer_t AudioSinks_exposer = AudioSinks_exposer_t( "AudioSinks" );
        bp::scope AudioSinks_scope( AudioSinks_exposer );
        AudioSinks_exposer.def( bp::indexing::vector_suite< std::vector< CLAM::AudioSink* > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::map< std::string, CLAM::BaseNetwork::Geometry >
        typedef bp::class_< std::map< std::string, CLAM::BaseNetwork::Geometry > > ProcessingsGeometriesMap_exposer_t;
        ProcessingsGeometriesMap_exposer_t ProcessingsGeometriesMap_exposer = ProcessingsGeometriesMap_exposer_t( "ProcessingsGeometriesMap" );
        bp::scope ProcessingsGeometriesMap_scope( ProcessingsGeometriesMap_exposer );
        ProcessingsGeometriesMap_exposer.def( bp::indexing::map_suite< std::map< std::string, CLAM::BaseNetwork::Geometry > >() );
    }

    { //::std::list< std::string >
        typedef bp::class_< std::list< std::string > > list_less__std_scope_string__grate__exposer_t;
        list_less__std_scope_string__grate__exposer_t list_less__std_scope_string__grate__exposer = list_less__std_scope_string__grate__exposer_t( "list_less__std_scope_string__grate_" );
        bp::scope list_less__std_scope_string__grate__scope( list_less__std_scope_string__grate__exposer );
        list_less__std_scope_string__grate__exposer.def( bp::indexing::list_suite< std::list< std::string > >() );
    }

    bp::class_< std::list< std::string > >("list_less__std_scope_string__grate_")    
        .def( bp::indexing::list_suite< std::list< std::string > >() );

    { //::std::list< CLAM::InPortBase* >
        typedef bp::class_< std::list< CLAM::InPortBase* > > InPortsList_exposer_t;
        InPortsList_exposer_t InPortsList_exposer = InPortsList_exposer_t( "InPortsList" );
        bp::scope InPortsList_scope( InPortsList_exposer );
        InPortsList_exposer.def( bp::indexing::list_suite< std::list< CLAM::InPortBase* > >::with_policies(bp::return_internal_reference< >()) );
    }

    bp::enum_< CLAM::EFFTType>("EFFTType")
        .value("eNone", CLAM::eNone)
        .value("eRFFTW", CLAM::eRFFTW)
        .value("eFFT_NREC", CLAM::eFFT_NREC)
        .value("eFFT_IUA", CLAM::eFFT_IUA)
        .export_values()
        ;

    bp::class_< Bindings::Audio >( "Audio" )    
        .def( bp::init< >() )    
        .def( 
            "GetBuffer"
            , (::boost::shared_ptr< Bindings::DataArray > ( ::Bindings::Audio::* )(  ) )( &::Bindings::Audio::GetBuffer ) )    
        .def( 
            "GetSize"
            , (::CLAM::TSize ( ::Bindings::Audio::* )(  ) )( &::Bindings::Audio::GetSize ) )    
        .def( 
            "SetSampleRate"
            , (void ( ::Bindings::Audio::* )( ::CLAM::TData ) )( &::Bindings::Audio::SetSampleRate )
            , ( bp::arg("s") ) )    
        .def( 
            "SetSize"
            , (void ( ::Bindings::Audio::* )( ::CLAM::TSize ) )( &::Bindings::Audio::SetSize )
            , ( bp::arg("s") ) )    
        .def( 
            "getBase"
            , (::CLAM::ProcessingData & ( ::Bindings::Audio::* )(  ) const)( &::Bindings::Audio::getBase )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "getReal"
            , (::CLAM::Audio & ( ::Bindings::Audio::* )(  ) const)( &::Bindings::Audio::getReal )
            , bp::return_value_policy< bp::reference_existing_object >() );

    bp::class_< Bindings::BPNetworkPlayer >( "BPNetworkPlayer" )    
        .def( bp::init< >() )    
        .def( bp::init< Bindings::BPNetworkPlayer const & >(( bp::arg("Net") )) )    
        .def( 
            "getReal"
            , (::CLAM::NetworkPlayer & ( ::Bindings::BPNetworkPlayer::* )(  ) const)( &::Bindings::BPNetworkPlayer::getReal )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "getSharedPointer"
            , (::boost::shared_ptr< CLAM::NetworkPlayer > ( ::Bindings::BPNetworkPlayer::* )(  ) const)( &::Bindings::BPNetworkPlayer::getSharedPointer ) );

    { //::Bindings::DataArray
        typedef bp::class_< Bindings::DataArray > DataArray_exposer_t;
        DataArray_exposer_t DataArray_exposer = DataArray_exposer_t( "DataArray", bp::init< CLAM::DataArray & >(( bp::arg("array") )) );
        bp::scope DataArray_scope( DataArray_exposer );
        { //::Bindings::DataArray::operator[]
        
            typedef ::CLAM::TData & ( ::Bindings::DataArray::*__getitem___function_type )( int const & ) ;
            
            DataArray_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::Bindings::DataArray::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::Bindings::DataArray::set
        
            typedef void ( ::Bindings::DataArray::*set_function_type )( int const &,::CLAM::TData const & ) ;
            
            DataArray_exposer.def( 
                "set"
                , set_function_type( &::Bindings::DataArray::set )
                , ( bp::arg("i"), bp::arg("data") ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< Bindings::DataArray > >();
    }

    bp::implicitly_convertible< CLAM::DataArray &, Bindings::DataArray >();

    bp::class_< Bindings::ProcessingConfig >( "ProcessingConfig" )    
        .def( 
            "getReal"
            , (::CLAM::ProcessingConfig & ( ::Bindings::ProcessingConfig::* )(  ) const)( &::Bindings::ProcessingConfig::getReal )
            , bp::return_value_policy< bp::reference_existing_object >() );

    bp::class_< Bindings::FFTConfig, bp::bases< Bindings::ProcessingConfig > >( "FFTConfig" )    
        .def( bp::init< >() )    
        .def( 
            "SetAudioSize"
            , (void ( ::Bindings::FFTConfig::* )( int ) )( &::Bindings::FFTConfig::SetAudioSize )
            , ( bp::arg("s") ) );

    { //::Bindings::Processing
        typedef bp::class_< Bindings::Processing > Processing_exposer_t;
        Processing_exposer_t Processing_exposer = Processing_exposer_t( "Processing" );
        bp::scope Processing_scope( Processing_exposer );
        Processing_exposer.def( bp::init< >() );
        Processing_exposer.def( bp::init< Bindings::Processing const & >(( bp::arg("Proc") )) );
        Processing_exposer.def( bp::init< CLAM::Processing & >(( bp::arg("proc") )) );
        { //::Bindings::Processing::getReal
        
            typedef ::boost::shared_ptr< CLAM::Processing > ( ::Bindings::Processing::*getReal_function_type )(  ) const;
            
            Processing_exposer.def( 
                "getReal"
                , getReal_function_type( &::Bindings::Processing::getReal ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< Bindings::Processing > >();
    }

    bp::implicitly_convertible< CLAM::Processing &, Bindings::Processing >();

    bp::class_< Bindings::MonoAudioFileReader, bp::bases< Bindings::Processing > >( "MonoAudioFileReader" )    
        .def( bp::init< >() )    
        .def( bp::init< boost::shared_ptr< Bindings::Processing > >(( bp::arg("Proc") )) )    
        .def( bp::init< CLAM::Processing & >(( bp::arg("Proc") )) )    
        .def( 
            "GetLength"
            , (int ( ::Bindings::MonoAudioFileReader::* )(  ) const)( &::Bindings::MonoAudioFileReader::GetLength ) );

    bp::implicitly_convertible< boost::shared_ptr< Bindings::Processing >, Bindings::MonoAudioFileReader >();

    bp::implicitly_convertible< CLAM::Processing &, Bindings::MonoAudioFileReader >();

    bp::class_< Bindings::MonoAudioFileReaderConfig, bp::bases< Bindings::ProcessingConfig > >( "MonoAudioFileReaderConfig" )    
        .def( bp::init< >() )    
        .def( 
            "SetSourceFile"
            , (void ( ::Bindings::MonoAudioFileReaderConfig::* )( char * ) )( &::Bindings::MonoAudioFileReaderConfig::SetSourceFile )
            , ( bp::arg("name") ) );

    bp::class_< Bindings::PANetworkPlayer, bp::bases< Bindings::BPNetworkPlayer > >( "PANetworkPlayer" )    
        .def( bp::init< >() );

    bp::class_< Bindings::Spectrum >( "Spectrum" )    
        .def( bp::init< >() )    
        .def( 
            "SetSize"
            , (void ( ::Bindings::Spectrum::* )( int ) )( &::Bindings::Spectrum::SetSize )
            , ( bp::arg("s") ) )    
        .def( 
            "SetType"
            , (void ( ::Bindings::Spectrum::* )( ::CLAM::SpecTypeFlags const & ) )( &::Bindings::Spectrum::SetType )
            , ( bp::arg("newFlags") ) )    
        .def( 
            "getBase"
            , (::CLAM::ProcessingData & ( ::Bindings::Spectrum::* )(  ) const)( &::Bindings::Spectrum::getBase )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "getReal"
            , (::CLAM::Spectrum & ( ::Bindings::Spectrum::* )(  ) const)( &::Bindings::Spectrum::getReal )
            , bp::return_value_policy< bp::reference_existing_object >() );

    bp::class_< Component_wrapper, boost::noncopyable >( "Component" )    
        .def( 
            "DeepCopy"
            , (::CLAM::Component * ( ::CLAM::Component::* )(  ) const)(&::CLAM::Component::DeepCopy)
            , (::CLAM::Component * ( Component_wrapper::* )(  ) const)(&Component_wrapper::default_DeepCopy)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetClassName"
            , bp::pure_virtual( (char const * ( ::CLAM::Component::* )(  ) const)(&::CLAM::Component::GetClassName) ) )    
        .def( 
            "LoadFrom"
            , bp::pure_virtual( (void ( ::CLAM::Component::* )( ::CLAM::Storage & ) )(&::CLAM::Component::LoadFrom) )
            , ( bp::arg("storage") ) )    
        .def( 
            "ShallowCopy"
            , (::CLAM::Component * ( ::CLAM::Component::* )(  ) const)(&::CLAM::Component::ShallowCopy)
            , (::CLAM::Component * ( Component_wrapper::* )(  ) const)(&Component_wrapper::default_ShallowCopy)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "StoreOn"
            , bp::pure_virtual( (void ( ::CLAM::Component::* )( ::CLAM::Storage & ) const)(&::CLAM::Component::StoreOn) )
            , ( bp::arg("storage") ) );

    { //::CLAM::Enum
        typedef bp::class_< Enum_wrapper, bp::bases< CLAM::Component >, boost::noncopyable > Enum_exposer_t;
        Enum_exposer_t Enum_exposer = Enum_exposer_t( "Enum", bp::init< CLAM::Enum::tEnumValue const *, int const & >(( bp::arg("values"), bp::arg("value") )) );
        bp::scope Enum_scope( Enum_exposer );
        bp::class_< CLAM::Enum::tEnumValue >( "tEnumValue" )    
            .def_readwrite( "value", &CLAM::Enum::tEnumValue::value );
        Enum_exposer.def( bp::init< CLAM::Enum::tEnumValue const *, std::string const & >(( bp::arg("values"), bp::arg("value") )) );
        { //::CLAM::Enum::DeepCopy
        
            typedef ::CLAM::Component * ( ::CLAM::Enum::*DeepCopy_function_type )(  ) const;
            typedef ::CLAM::Component * ( Enum_wrapper::*default_DeepCopy_function_type )(  ) const;
            
            Enum_exposer.def( 
                "DeepCopy"
                , DeepCopy_function_type(&::CLAM::Enum::DeepCopy)
                , default_DeepCopy_function_type(&Enum_wrapper::default_DeepCopy)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Enum::GetClassName
        
            typedef char const * ( ::CLAM::Enum::*GetClassName_function_type )(  ) const;
            typedef char const * ( Enum_wrapper::*default_GetClassName_function_type )(  ) const;
            
            Enum_exposer.def( 
                "GetClassName"
                , GetClassName_function_type(&::CLAM::Enum::GetClassName)
                , default_GetClassName_function_type(&Enum_wrapper::default_GetClassName) );
        
        }
        { //::CLAM::Enum::GetString
        
            typedef ::std::string ( ::CLAM::Enum::*GetString_function_type )(  ) const;
            
            Enum_exposer.def( 
                "GetString"
                , GetString_function_type( &::CLAM::Enum::GetString ) );
        
        }
        { //::CLAM::Enum::GetSymbolMap
        
            typedef ::CLAM::Enum::tEnumValue const * ( ::CLAM::Enum::*GetSymbolMap_function_type )(  ) const;
            
            Enum_exposer.def( 
                "GetSymbolMap"
                , GetSymbolMap_function_type( &::CLAM::Enum::GetSymbolMap )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Enum::GetValue
        
            typedef int ( ::CLAM::Enum::*GetValue_function_type )(  ) const;
            
            Enum_exposer.def( 
                "GetValue"
                , GetValue_function_type( &::CLAM::Enum::GetValue ) );
        
        }
        { //::CLAM::Enum::LoadFrom
        
            typedef void ( ::CLAM::Enum::*LoadFrom_function_type )( ::CLAM::Storage & ) ;
            typedef void ( Enum_wrapper::*default_LoadFrom_function_type )( ::CLAM::Storage & ) ;
            
            Enum_exposer.def( 
                "LoadFrom"
                , LoadFrom_function_type(&::CLAM::Enum::LoadFrom)
                , default_LoadFrom_function_type(&Enum_wrapper::default_LoadFrom)
                , ( bp::arg("storage") ) );
        
        }
        { //::CLAM::Enum::SetValue
        
            typedef void ( ::CLAM::Enum::*SetValue_function_type )( int const ) ;
            
            Enum_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::CLAM::Enum::SetValue )
                , ( bp::arg("v") ) );
        
        }
        { //::CLAM::Enum::SetValue
        
            typedef void ( ::CLAM::Enum::*SetValue_function_type )( ::std::string const & ) ;
            
            Enum_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::CLAM::Enum::SetValue )
                , ( bp::arg("s") ) );
        
        }
        { //::CLAM::Enum::SetValueSafely
        
            typedef void ( ::CLAM::Enum::*SetValueSafely_function_type )( int const ) ;
            
            Enum_exposer.def( 
                "SetValueSafely"
                , SetValueSafely_function_type( &::CLAM::Enum::SetValueSafely )
                , ( bp::arg("v") ) );
        
        }
        { //::CLAM::Enum::SetValueSafely
        
            typedef void ( ::CLAM::Enum::*SetValueSafely_function_type )( ::std::string const & ) ;
            
            Enum_exposer.def( 
                "SetValueSafely"
                , SetValueSafely_function_type( &::CLAM::Enum::SetValueSafely )
                , ( bp::arg("s") ) );
        
        }
        { //::CLAM::Enum::ShallowCopy
        
            typedef ::CLAM::Component * ( ::CLAM::Enum::*ShallowCopy_function_type )(  ) const;
            typedef ::CLAM::Component * ( Enum_wrapper::*default_ShallowCopy_function_type )(  ) const;
            
            Enum_exposer.def( 
                "ShallowCopy"
                , ShallowCopy_function_type(&::CLAM::Enum::ShallowCopy)
                , default_ShallowCopy_function_type(&Enum_wrapper::default_ShallowCopy)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Enum::Species
        
            typedef ::CLAM::Component * ( ::CLAM::Enum::*Species_function_type )(  ) const;
            
            Enum_exposer.def( 
                "Species"
                , bp::pure_virtual( Species_function_type(&::CLAM::Enum::Species) )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Enum::StoreOn
        
            typedef void ( ::CLAM::Enum::*StoreOn_function_type )( ::CLAM::Storage & ) const;
            typedef void ( Enum_wrapper::*default_StoreOn_function_type )( ::CLAM::Storage & ) const;
            
            Enum_exposer.def( 
                "StoreOn"
                , StoreOn_function_type(&::CLAM::Enum::StoreOn)
                , default_StoreOn_function_type(&Enum_wrapper::default_StoreOn)
                , ( bp::arg("storage") ) );
        
        }
        Enum_exposer.def( "__int__", &CLAM::Enum::operator int  );
        { //::CLAM::Enum::operator=
        
            typedef ::CLAM::Enum & ( ::CLAM::Enum::*assign_function_type )( int const & ) ;
            
            Enum_exposer.def( 
                "assign"
                , assign_function_type( &::CLAM::Enum::operator= )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        { //::CLAM::Enum::operator=
        
            typedef ::CLAM::Enum & ( ::CLAM::Enum::*assign_function_type )( ::std::string const & ) ;
            
            Enum_exposer.def( 
                "assign"
                , assign_function_type( &::CLAM::Enum::operator= )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        { //::CLAM::Enum::operator=
        
            typedef ::CLAM::Enum & ( ::CLAM::Enum::*assign_function_type )( ::CLAM::Enum const & ) ;
            
            Enum_exposer.def( 
                "assign"
                , assign_function_type( &::CLAM::Enum::operator= )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        Enum_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::class_< Err_wrapper >( "Err" )    
        .def( bp::init< >() )    
        .def( bp::init< char const * >(( bp::arg("msg") )) )    
        .def( bp::init< CLAM::Err const & >(( bp::arg("arg0") )) )    
        .def( 
            "Embed"
            , (void ( ::CLAM::Err::* )( ::std::exception const & ) )( &::CLAM::Err::Embed )
            , ( bp::arg("arg0") ) )    
        .def( 
            "Embed"
            , (void ( ::CLAM::Err::* )( char const * ) )( &::CLAM::Err::Embed )
            , ( bp::arg("str") ) )    
        .def( 
            "Print"
            , (void ( ::CLAM::Err::* )(  ) const)( &::CLAM::Err::Print ) )    
        .def( 
            "what"
            , (char const * ( ::CLAM::Err::* )(  ) const)(&::CLAM::Err::what)
            , (char const * ( Err_wrapper::* )(  ) const)(&Err_wrapper::default_what) );

    bp::implicitly_convertible< char const *, CLAM::Err >();

    bp::class_< CLAM::ErrNotFound, bp::bases< CLAM::Err > >( "ErrNotFound" );

    bp::class_< FFT_wrapper, boost::noncopyable >( "FFT" )    
        .def( bp::init< >() )    
        .def( bp::init< CLAM::FFTConfig const & >(( bp::arg("config") )) )    
        .def( 
            "GetClassName"
            , (char const * ( ::CLAM::FFT::* )(  ) const)(&::CLAM::FFT::GetClassName)
            , (char const * ( FFT_wrapper::* )(  ) const)(&FFT_wrapper::default_GetClassName) )    
        .def( 
            "AbleToExecute"
            , (bool ( FFT_wrapper::* )(  ) const)(&FFT_wrapper::AbleToExecute) )    
        .def( 
            "AddConfigErrorMessage"
            , (void ( FFT_wrapper::* )( ::std::string const & ) )(&FFT_wrapper::AddConfigErrorMessage)
            , ( bp::arg("msg") ) )    
        .def( 
            "BackendBufferSize"
            , (unsigned int ( FFT_wrapper::* )(  ) )(&FFT_wrapper::BackendBufferSize) )    
        .def( 
            "BackendSampleRate"
            , (unsigned int ( FFT_wrapper::* )(  ) )(&FFT_wrapper::BackendSampleRate) )    
        .def( 
            "ChangeSize"
            , (void ( FFT_wrapper::* )( int ) )(&FFT_wrapper::ChangeSize)
            , ( bp::arg("n") ) )    
        .def( 
            "ConcreteConfigure"
            , (bool ( FFT_wrapper::* )( ::CLAM::ProcessingConfig const & ) )(&FFT_wrapper::ConcreteConfigure)
            , ( bp::arg("arg0") ) )    
        .def( 
            "ConcreteStart"
            , (bool ( FFT_wrapper::* )(  ) )(&FFT_wrapper::ConcreteStart) )    
        .def( 
            "ConcreteStop"
            , (bool ( FFT_wrapper::* )(  ) )(&FFT_wrapper::ConcreteStop) )    
        .def( 
            "GetSize"
            , (int ( FFT_wrapper::* )(  ) )(&FFT_wrapper::GetSize) )    
        .def( 
            "SetExecState"
            , (void ( FFT_wrapper::* )( ::CLAM::Processing::ExecState ) )(&FFT_wrapper::SetExecState)
            , ( bp::arg("state") ) );

    bp::implicitly_convertible< CLAM::FFTConfig const &, CLAM::FFT >();

    { //::CLAM::Processing
        typedef bp::class_< Processing_wrapper, boost::noncopyable > Processing_exposer_t;
        Processing_exposer_t Processing_exposer = Processing_exposer_t( "Processing" );
        bp::scope Processing_scope( Processing_exposer );
        bp::enum_< CLAM::Processing::ExecState>("ExecState")
            .value("Unconfigured", CLAM::Processing::Unconfigured)
            .value("Ready", CLAM::Processing::Ready)
            .value("Running", CLAM::Processing::Running)
            .export_values()
            ;
        Processing_exposer.def( bp::init< >() );
        { //::CLAM::Processing::AbleToExecute
        
            typedef bool ( Processing_wrapper::*AbleToExecute_function_type )(  ) const;
            
            Processing_exposer.def( 
                "AbleToExecute"
                , AbleToExecute_function_type( &Processing_wrapper::AbleToExecute ) );
        
        }
        { //::CLAM::Processing::AddConfigErrorMessage
        
            typedef void ( Processing_wrapper::*AddConfigErrorMessage_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "AddConfigErrorMessage"
                , AddConfigErrorMessage_function_type( &Processing_wrapper::AddConfigErrorMessage )
                , ( bp::arg("msg") ) );
        
        }
        { //::CLAM::Processing::BackendBufferSize
        
            typedef unsigned int ( Processing_wrapper::*BackendBufferSize_function_type )(  ) ;
            
            Processing_exposer.def( 
                "BackendBufferSize"
                , BackendBufferSize_function_type( &Processing_wrapper::BackendBufferSize ) );
        
        }
        { //::CLAM::Processing::BackendSampleRate
        
            typedef unsigned int ( Processing_wrapper::*BackendSampleRate_function_type )(  ) ;
            
            Processing_exposer.def( 
                "BackendSampleRate"
                , BackendSampleRate_function_type( &Processing_wrapper::BackendSampleRate ) );
        
        }
        { //::CLAM::Processing::CanConsumeAndProduce
        
            typedef bool ( ::CLAM::Processing::*CanConsumeAndProduce_function_type )(  ) ;
            
            Processing_exposer.def( 
                "CanConsumeAndProduce"
                , CanConsumeAndProduce_function_type( &::CLAM::Processing::CanConsumeAndProduce ) );
        
        }
        { //::CLAM::Processing::CanProcessInplace
        
            typedef bool ( ::CLAM::Processing::*CanProcessInplace_function_type )(  ) ;
            typedef bool ( Processing_wrapper::*default_CanProcessInplace_function_type )(  ) ;
            
            Processing_exposer.def( 
                "CanProcessInplace"
                , CanProcessInplace_function_type(&::CLAM::Processing::CanProcessInplace)
                , default_CanProcessInplace_function_type(&Processing_wrapper::default_CanProcessInplace) );
        
        }
        { //::CLAM::Processing::ConcreteConfigure
        
            typedef bool ( Processing_wrapper::*ConcreteConfigure_function_type )( ::CLAM::ProcessingConfig const & ) ;
            
            Processing_exposer.def( 
                "ConcreteConfigure"
                , ConcreteConfigure_function_type( &Processing_wrapper::ConcreteConfigure )
                , ( bp::arg("arg0") ) );
        
        }
        { //::CLAM::Processing::ConcreteStart
        
            typedef bool ( Processing_wrapper::*ConcreteStart_function_type )(  ) ;
            
            Processing_exposer.def( 
                "ConcreteStart"
                , ConcreteStart_function_type( &Processing_wrapper::ConcreteStart ) );
        
        }
        { //::CLAM::Processing::ConcreteStop
        
            typedef bool ( Processing_wrapper::*ConcreteStop_function_type )(  ) ;
            
            Processing_exposer.def( 
                "ConcreteStop"
                , ConcreteStop_function_type( &Processing_wrapper::ConcreteStop ) );
        
        }
        { //::CLAM::Processing::Configure
        
            typedef bool ( ::CLAM::Processing::*Configure_function_type )( ::CLAM::ProcessingConfig const & ) ;
            
            Processing_exposer.def( 
                "Configure"
                , Configure_function_type( &::CLAM::Processing::Configure )
                , ( bp::arg("config") ) );
        
        }
        { //::CLAM::Processing::Do
        
            typedef bool ( ::CLAM::Processing::*Do_function_type )(  ) ;
            
            Processing_exposer.def( 
                "Do"
                , bp::pure_virtual( Do_function_type(&::CLAM::Processing::Do) ) );
        
        }
        { //::CLAM::Processing::GetClassName
        
            typedef char const * ( ::CLAM::Processing::*GetClassName_function_type )(  ) const;
            
            Processing_exposer.def( 
                "GetClassName"
                , bp::pure_virtual( GetClassName_function_type(&::CLAM::Processing::GetClassName) ) );
        
        }
        { //::CLAM::Processing::GetConfig
        
            typedef ::CLAM::ProcessingConfig const & ( ::CLAM::Processing::*GetConfig_function_type )(  ) const;
            
            Processing_exposer.def( 
                "GetConfig"
                , GetConfig_function_type(&::CLAM::Processing::GetConfig)
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::CLAM::Processing::GetConfigErrorMessage
        
            typedef ::std::string const & ( ::CLAM::Processing::*GetConfigErrorMessage_function_type )(  ) const;
            
            Processing_exposer.def( 
                "GetConfigErrorMessage"
                , GetConfigErrorMessage_function_type( &::CLAM::Processing::GetConfigErrorMessage )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::CLAM::Processing::GetExecStateString
        
            typedef ::std::string ( ::CLAM::Processing::*GetExecStateString_function_type )(  ) const;
            
            Processing_exposer.def( 
                "GetExecStateString"
                , GetExecStateString_function_type( &::CLAM::Processing::GetExecStateString ) );
        
        }
        { //::CLAM::Processing::GetInControl
        
            typedef ::CLAM::InControl & ( ::CLAM::Processing::*GetInControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "GetInControl"
                , GetInControl_function_type( &::CLAM::Processing::GetInControl )
                , ( bp::arg("name") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetInControls
        
            typedef ::CLAM::InControlRegistry & ( ::CLAM::Processing::*GetInControls_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetInControls"
                , GetInControls_function_type( &::CLAM::Processing::GetInControls )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetInPort
        
            typedef ::CLAM::InPortBase & ( ::CLAM::Processing::*GetInPort_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "GetInPort"
                , GetInPort_function_type( &::CLAM::Processing::GetInPort )
                , ( bp::arg("name") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetInPorts
        
            typedef ::CLAM::InPortRegistry & ( ::CLAM::Processing::*GetInPorts_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetInPorts"
                , GetInPorts_function_type( &::CLAM::Processing::GetInPorts )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetOutControl
        
            typedef ::CLAM::OutControl & ( ::CLAM::Processing::*GetOutControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "GetOutControl"
                , GetOutControl_function_type( &::CLAM::Processing::GetOutControl )
                , ( bp::arg("name") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetOutControls
        
            typedef ::CLAM::OutControlRegistry & ( ::CLAM::Processing::*GetOutControls_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetOutControls"
                , GetOutControls_function_type( &::CLAM::Processing::GetOutControls )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetOutPort
        
            typedef ::CLAM::OutPortBase & ( ::CLAM::Processing::*GetOutPort_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "GetOutPort"
                , GetOutPort_function_type( &::CLAM::Processing::GetOutPort )
                , ( bp::arg("name") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetOutPorts
        
            typedef ::CLAM::OutPortRegistry & ( ::CLAM::Processing::*GetOutPorts_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetOutPorts"
                , GetOutPorts_function_type( &::CLAM::Processing::GetOutPorts )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetTypedInControls
        
            typedef ::CLAM::TypedInControlRegistry & ( ::CLAM::Processing::*GetTypedInControls_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetTypedInControls"
                , GetTypedInControls_function_type( &::CLAM::Processing::GetTypedInControls )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::GetTypedOutControls
        
            typedef ::CLAM::TypedOutControlRegistry & ( ::CLAM::Processing::*GetTypedOutControls_function_type )(  ) ;
            
            Processing_exposer.def( 
                "GetTypedOutControls"
                , GetTypedOutControls_function_type( &::CLAM::Processing::GetTypedOutControls )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::Processing::HasInControl
        
            typedef bool ( ::CLAM::Processing::*HasInControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasInControl"
                , HasInControl_function_type( &::CLAM::Processing::HasInControl )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::HasInPort
        
            typedef bool ( ::CLAM::Processing::*HasInPort_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasInPort"
                , HasInPort_function_type( &::CLAM::Processing::HasInPort )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::HasOutControl
        
            typedef bool ( ::CLAM::Processing::*HasOutControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasOutControl"
                , HasOutControl_function_type( &::CLAM::Processing::HasOutControl )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::HasOutPort
        
            typedef bool ( ::CLAM::Processing::*HasOutPort_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasOutPort"
                , HasOutPort_function_type( &::CLAM::Processing::HasOutPort )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::HasTypedInControl
        
            typedef bool ( ::CLAM::Processing::*HasTypedInControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasTypedInControl"
                , HasTypedInControl_function_type( &::CLAM::Processing::HasTypedInControl )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::HasTypedOutControl
        
            typedef bool ( ::CLAM::Processing::*HasTypedOutControl_function_type )( ::std::string const & ) ;
            
            Processing_exposer.def( 
                "HasTypedOutControl"
                , HasTypedOutControl_function_type( &::CLAM::Processing::HasTypedOutControl )
                , ( bp::arg("name") ) );
        
        }
        { //::CLAM::Processing::IsConfigured
        
            typedef bool ( ::CLAM::Processing::*IsConfigured_function_type )(  ) const;
            
            Processing_exposer.def( 
                "IsConfigured"
                , IsConfigured_function_type( &::CLAM::Processing::IsConfigured ) );
        
        }
        { //::CLAM::Processing::IsRunning
        
            typedef bool ( ::CLAM::Processing::*IsRunning_function_type )(  ) const;
            
            Processing_exposer.def( 
                "IsRunning"
                , IsRunning_function_type( &::CLAM::Processing::IsRunning ) );
        
        }
        { //::CLAM::Processing::IsSyncSource
        
            typedef bool ( ::CLAM::Processing::*IsSyncSource_function_type )(  ) const;
            typedef bool ( Processing_wrapper::*default_IsSyncSource_function_type )(  ) const;
            
            Processing_exposer.def( 
                "IsSyncSource"
                , IsSyncSource_function_type(&::CLAM::Processing::IsSyncSource)
                , default_IsSyncSource_function_type(&Processing_wrapper::default_IsSyncSource) );
        
        }
        { //::CLAM::Processing::ModifiesPortsAndControlsAtConfiguration
        
            typedef bool ( ::CLAM::Processing::*ModifiesPortsAndControlsAtConfiguration_function_type )(  ) ;
            typedef bool ( Processing_wrapper::*default_ModifiesPortsAndControlsAtConfiguration_function_type )(  ) ;
            
            Processing_exposer.def( 
                "ModifiesPortsAndControlsAtConfiguration"
                , ModifiesPortsAndControlsAtConfiguration_function_type(&::CLAM::Processing::ModifiesPortsAndControlsAtConfiguration)
                , default_ModifiesPortsAndControlsAtConfiguration_function_type(&Processing_wrapper::default_ModifiesPortsAndControlsAtConfiguration) );
        
        }
        { //::CLAM::Processing::RegisterInControl
        
            typedef void ( ::CLAM::Processing::*RegisterInControl_function_type )( ::CLAM::InControl * ) ;
            
            Processing_exposer.def( 
                "RegisterInControl"
                , RegisterInControl_function_type( &::CLAM::Processing::RegisterInControl )
                , ( bp::arg("in") ) );
        
        }
        { //::CLAM::Processing::RegisterInPort
        
            typedef void ( ::CLAM::Processing::*RegisterInPort_function_type )( ::CLAM::InPortBase * ) ;
            
            Processing_exposer.def( 
                "RegisterInPort"
                , RegisterInPort_function_type( &::CLAM::Processing::RegisterInPort )
                , ( bp::arg("in") ) );
        
        }
        { //::CLAM::Processing::RegisterOutControl
        
            typedef void ( ::CLAM::Processing::*RegisterOutControl_function_type )( ::CLAM::OutControl * ) ;
            
            Processing_exposer.def( 
                "RegisterOutControl"
                , RegisterOutControl_function_type( &::CLAM::Processing::RegisterOutControl )
                , ( bp::arg("out") ) );
        
        }
        { //::CLAM::Processing::RegisterOutPort
        
            typedef void ( ::CLAM::Processing::*RegisterOutPort_function_type )( ::CLAM::OutPortBase * ) ;
            
            Processing_exposer.def( 
                "RegisterOutPort"
                , RegisterOutPort_function_type( &::CLAM::Processing::RegisterOutPort )
                , ( bp::arg("out") ) );
        
        }
        { //::CLAM::Processing::RegisterTypedInControl
        
            typedef void ( ::CLAM::Processing::*RegisterTypedInControl_function_type )( ::CLAM::BaseTypedInControl * ) ;
            
            Processing_exposer.def( 
                "RegisterTypedInControl"
                , RegisterTypedInControl_function_type( &::CLAM::Processing::RegisterTypedInControl )
                , ( bp::arg("in") ) );
        
        }
        { //::CLAM::Processing::RegisterTypedOutControl
        
            typedef void ( ::CLAM::Processing::*RegisterTypedOutControl_function_type )( ::CLAM::BaseTypedOutControl * ) ;
            
            Processing_exposer.def( 
                "RegisterTypedOutControl"
                , RegisterTypedOutControl_function_type( &::CLAM::Processing::RegisterTypedOutControl )
                , ( bp::arg("out") ) );
        
        }
        { //::CLAM::Processing::SetExecState
        
            typedef void ( Processing_wrapper::*SetExecState_function_type )( ::CLAM::Processing::ExecState ) ;
            
            Processing_exposer.def( 
                "SetExecState"
                , SetExecState_function_type( &Processing_wrapper::SetExecState )
                , ( bp::arg("state") ) );
        
        }
        { //::CLAM::Processing::SetNetworkBackLink
        
            typedef void ( ::CLAM::Processing::*SetNetworkBackLink_function_type )( ::CLAM::Network * ) ;
            
            Processing_exposer.def( 
                "SetNetworkBackLink"
                , SetNetworkBackLink_function_type( &::CLAM::Processing::SetNetworkBackLink )
                , ( bp::arg("network") ) );
        
        }
        { //::CLAM::Processing::SetParent
        
            typedef void ( ::CLAM::Processing::*SetParent_function_type )( ::CLAM::Processing * ) ;
            
            Processing_exposer.def( 
                "SetParent"
                , SetParent_function_type( &::CLAM::Processing::SetParent )
                , ( bp::arg("p") ) );
        
        }
        { //::CLAM::Processing::Start
        
            typedef void ( ::CLAM::Processing::*Start_function_type )(  ) ;
            
            Processing_exposer.def( 
                "Start"
                , Start_function_type( &::CLAM::Processing::Start ) );
        
        }
        { //::CLAM::Processing::Stop
        
            typedef void ( ::CLAM::Processing::*Stop_function_type )(  ) ;
            
            Processing_exposer.def( 
                "Stop"
                , Stop_function_type( &::CLAM::Processing::Stop ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< CLAM::Processing > >();
    }

    bp::class_< FFT_base_wrapper, bp::bases< CLAM::Processing >, boost::noncopyable >( "FFT_base" )    
        .def( bp::init< >() )    
        .def( 
            "ChangeSize"
            , (void ( FFT_base_wrapper::* )( int ) )(&FFT_base_wrapper::ChangeSize)
            , ( bp::arg("n") ) )    
        .def( 
            "CheckTypes"
            , (void ( ::CLAM::FFT_base::* )( ::CLAM::Audio const &,::CLAM::Spectrum const & ) const)( &::CLAM::FFT_base::CheckTypes )
            , ( bp::arg("in"), bp::arg("out") ) )    
        .def( 
            "ConcreteConfigure"
            , (bool ( FFT_base_wrapper::* )( ::CLAM::ProcessingConfig const & ) )(&FFT_base_wrapper::ConcreteConfigure)
            , ( bp::arg("arg0") ) )    
        .def( 
            "DisableExecution"
            , (bool ( ::CLAM::FFT_base::* )(  ) )(&::CLAM::FFT_base::DisableExecution)
            , (bool ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::default_DisableExecution) )    
        .def( 
            "Do"
            , bp::pure_virtual( (bool ( ::CLAM::FFT_base::* )(  ) )(&::CLAM::FFT_base::Do) ) )    
        .def( 
            "Do"
            , bp::pure_virtual( (bool ( ::CLAM::FFT_base::* )( ::CLAM::Audio const &,::CLAM::Spectrum & ) )(&::CLAM::FFT_base::Do) )
            , ( bp::arg("in"), bp::arg("out") ) )    
        .def( 
            "EnableExecution"
            , (bool ( ::CLAM::FFT_base::* )(  ) )(&::CLAM::FFT_base::EnableExecution)
            , (bool ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::default_EnableExecution) )    
        .def( 
            "GetConfig"
            , (::CLAM::ProcessingConfig const & ( ::CLAM::FFT_base::* )(  ) const)(&::CLAM::FFT_base::GetConfig)
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetSize"
            , (int ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::GetSize) )    
        .def( 
            "MayDisableExecution"
            , (bool ( ::CLAM::FFT_base::* )(  ) const)(&::CLAM::FFT_base::MayDisableExecution)
            , (bool ( FFT_base_wrapper::* )(  ) const)(&FFT_base_wrapper::default_MayDisableExecution) )    
        .def( 
            "SetPrototypes"
            , (bool ( ::CLAM::FFT_base::* )( ::CLAM::Audio const &,::CLAM::Spectrum const & ) )( &::CLAM::FFT_base::SetPrototypes )
            , ( bp::arg("in"), bp::arg("out") ) )    
        .def( 
            "SetPrototypes"
            , (bool ( ::CLAM::FFT_base::* )(  ) )( &::CLAM::FFT_base::SetPrototypes ) )    
        .def( 
            "ToComplex"
            , bp::pure_virtual( (void ( ::CLAM::FFT_base::* )( ::CLAM::Spectrum & ) )(&::CLAM::FFT_base::ToComplex) )
            , ( bp::arg("out") ) )    
        .def( 
            "ToOther"
            , (void ( ::CLAM::FFT_base::* )( ::CLAM::Spectrum & ) )(&::CLAM::FFT_base::ToOther)
            , (void ( FFT_base_wrapper::* )( ::CLAM::Spectrum & ) )(&FFT_base_wrapper::default_ToOther)
            , ( bp::arg("out") ) )    
        .def( 
            "UnsetPrototypes"
            , (bool ( ::CLAM::FFT_base::* )(  ) )( &::CLAM::FFT_base::UnsetPrototypes ) )    
        .def( 
            "AbleToExecute"
            , (bool ( FFT_base_wrapper::* )(  ) const)(&FFT_base_wrapper::AbleToExecute) )    
        .def( 
            "AddConfigErrorMessage"
            , (void ( FFT_base_wrapper::* )( ::std::string const & ) )(&FFT_base_wrapper::AddConfigErrorMessage)
            , ( bp::arg("msg") ) )    
        .def( 
            "BackendBufferSize"
            , (unsigned int ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::BackendBufferSize) )    
        .def( 
            "BackendSampleRate"
            , (unsigned int ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::BackendSampleRate) )    
        .def( 
            "ConcreteStart"
            , (bool ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::ConcreteStart) )    
        .def( 
            "ConcreteStop"
            , (bool ( FFT_base_wrapper::* )(  ) )(&FFT_base_wrapper::ConcreteStop) )    
        .def( 
            "GetClassName"
            , bp::pure_virtual( (char const * ( ::CLAM::Processing::* )(  ) const)(&::CLAM::Processing::GetClassName) ) )    
        .def( 
            "SetExecState"
            , (void ( FFT_base_wrapper::* )( ::CLAM::Processing::ExecState ) )(&FFT_base_wrapper::SetExecState)
            , ( bp::arg("state") ) );

    bp::class_< FFT_ooura_wrapper, bp::bases< CLAM::FFT_base >, boost::noncopyable >( "FFT_ooura" )    
        .def( bp::init< >() )    
        .def( bp::init< CLAM::FFTConfig const & >(( bp::arg("c") )) )    
        .def( 
            "Do"
            , (bool ( ::CLAM::FFT_ooura::* )(  ) )(&::CLAM::FFT_ooura::Do)
            , (bool ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::default_Do) )    
        .def( 
            "Do"
            , (bool ( ::CLAM::FFT_ooura::* )( ::CLAM::Audio const &,::CLAM::Spectrum & ) )(&::CLAM::FFT_ooura::Do)
            , (bool ( FFT_ooura_wrapper::* )( ::CLAM::Audio const &,::CLAM::Spectrum & ) )(&FFT_ooura_wrapper::default_Do)
            , ( bp::arg("in"), bp::arg("out") ) )    
        .def( 
            "Do"
            , (bool ( ::CLAM::FFT_ooura::* )( ::CLAM::ProcessingData const &,::CLAM::ProcessingData & ) )( &::CLAM::FFT_ooura::Do )
            , ( bp::arg("in"), bp::arg("out") ) )    
        .def( 
            "GetClassName"
            , (char const * ( ::CLAM::FFT_ooura::* )(  ) const)(&::CLAM::FFT_ooura::GetClassName)
            , (char const * ( FFT_ooura_wrapper::* )(  ) const)(&FFT_ooura_wrapper::default_GetClassName) )    
        .def( 
            "MayDisableExecution"
            , (bool ( ::CLAM::FFT_ooura::* )(  ) const)(&::CLAM::FFT_ooura::MayDisableExecution)
            , (bool ( FFT_ooura_wrapper::* )(  ) const)(&FFT_ooura_wrapper::default_MayDisableExecution) )    
        .def( 
            "bitrv2"
            , (void (*)( int,int *,::CLAM::TData * ))( &::CLAM::FFT_ooura::bitrv2 )
            , ( bp::arg("n"), bp::arg("ip"), bp::arg("a") ) )    
        .def( 
            "cft1st"
            , (void (*)( int,::CLAM::TData *,::CLAM::TData * ))( &::CLAM::FFT_ooura::cft1st )
            , ( bp::arg("n"), bp::arg("a"), bp::arg("w") ) )    
        .def( 
            "cftbsub"
            , (void (*)( int,::CLAM::TData *,::CLAM::TData * ))( &::CLAM::FFT_ooura::cftbsub )
            , ( bp::arg("n"), bp::arg("a"), bp::arg("w") ) )    
        .def( 
            "cftfsub"
            , (void (*)( int,::CLAM::TData *,::CLAM::TData * ))( &::CLAM::FFT_ooura::cftfsub )
            , ( bp::arg("n"), bp::arg("a"), bp::arg("w") ) )    
        .def( 
            "cftmdl"
            , (void (*)( int,int,::CLAM::TData *,::CLAM::TData * ))( &::CLAM::FFT_ooura::cftmdl )
            , ( bp::arg("n"), bp::arg("l"), bp::arg("a"), bp::arg("w") ) )    
        .def( 
            "makect"
            , (void (*)( int,int *,::CLAM::TData * ))( &::CLAM::FFT_ooura::makect )
            , ( bp::arg("nc"), bp::arg("ip"), bp::arg("c") ) )    
        .def( 
            "makewt"
            , (void (*)( int,int *,::CLAM::TData * ))( &::CLAM::FFT_ooura::makewt )
            , ( bp::arg("nw"), bp::arg("ip"), bp::arg("w") ) )    
        .def( 
            "rdft"
            , (void (*)( int,int,::CLAM::TData *,int *,::CLAM::TData * ))( &::CLAM::FFT_ooura::rdft )
            , ( bp::arg("n"), bp::arg("isgn"), bp::arg("a"), bp::arg("ip"), bp::arg("w") ) )    
        .def( 
            "rftbsub"
            , (void (*)( int,::CLAM::TData *,int,::CLAM::TData * ))( &::CLAM::FFT_ooura::rftbsub )
            , ( bp::arg("n"), bp::arg("a"), bp::arg("nc"), bp::arg("c") ) )    
        .def( 
            "rftfsub"
            , (void (*)( int,::CLAM::TData *,int,::CLAM::TData * ))( &::CLAM::FFT_ooura::rftfsub )
            , ( bp::arg("n"), bp::arg("a"), bp::arg("nc"), bp::arg("c") ) )    
        .def( 
            "AbleToExecute"
            , (bool ( FFT_ooura_wrapper::* )(  ) const)(&FFT_ooura_wrapper::AbleToExecute) )    
        .def( 
            "AddConfigErrorMessage"
            , (void ( FFT_ooura_wrapper::* )( ::std::string const & ) )(&FFT_ooura_wrapper::AddConfigErrorMessage)
            , ( bp::arg("msg") ) )    
        .def( 
            "BackendBufferSize"
            , (unsigned int ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::BackendBufferSize) )    
        .def( 
            "BackendSampleRate"
            , (unsigned int ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::BackendSampleRate) )    
        .def( 
            "ChangeSize"
            , (void ( FFT_ooura_wrapper::* )( int ) )(&FFT_ooura_wrapper::ChangeSize)
            , ( bp::arg("n") ) )    
        .def( 
            "ConcreteStart"
            , (bool ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::ConcreteStart) )    
        .def( 
            "ConcreteStop"
            , (bool ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::ConcreteStop) )    
        .def( 
            "GetSize"
            , (int ( FFT_ooura_wrapper::* )(  ) )(&FFT_ooura_wrapper::GetSize) )    
        .def( 
            "SetExecState"
            , (void ( FFT_ooura_wrapper::* )( ::CLAM::Processing::ExecState ) )(&FFT_ooura_wrapper::SetExecState)
            , ( bp::arg("state") ) )    
        .staticmethod( "bitrv2" )    
        .staticmethod( "cft1st" )    
        .staticmethod( "cftbsub" )    
        .staticmethod( "cftfsub" )    
        .staticmethod( "cftmdl" )    
        .staticmethod( "makect" )    
        .staticmethod( "makewt" )    
        .staticmethod( "rdft" )    
        .staticmethod( "rftbsub" )    
        .staticmethod( "rftfsub" );

    bp::implicitly_convertible< CLAM::FFTConfig const &, CLAM::FFT_ooura >();

    { //::CLAM::FlagsBase
        typedef bp::class_< FlagsBase_wrapper, bp::bases< CLAM::Component >, boost::noncopyable > FlagsBase_exposer_t;
        FlagsBase_exposer_t FlagsBase_exposer = FlagsBase_exposer_t( "FlagsBase" );
        bp::scope FlagsBase_scope( FlagsBase_exposer );
        bp::class_< CLAM::FlagsBase::tFlagValue >( "tFlagValue" )    
            .def_readwrite( "value", &CLAM::FlagsBase::tFlagValue::value );
        { //::CLAM::FlagsBase::CheckInvariant
        
            typedef bool ( ::CLAM::FlagsBase::*CheckInvariant_function_type )(  ) ;
            
            FlagsBase_exposer.def( 
                "CheckInvariant"
                , CheckInvariant_function_type( &::CLAM::FlagsBase::CheckInvariant ) );
        
        }
        { //::CLAM::FlagsBase::GetFlagPosition
        
            typedef unsigned int ( ::CLAM::FlagsBase::*GetFlagPosition_function_type )( ::std::string const & ) const;
            
            FlagsBase_exposer.def( 
                "GetFlagPosition"
                , GetFlagPosition_function_type( &::CLAM::FlagsBase::GetFlagPosition )
                , ( bp::arg("whichOne") ) );
        
        }
        { //::CLAM::FlagsBase::GetFlagString
        
            typedef ::std::string ( ::CLAM::FlagsBase::*GetFlagString_function_type )( unsigned int ) const;
            
            FlagsBase_exposer.def( 
                "GetFlagString"
                , GetFlagString_function_type( &::CLAM::FlagsBase::GetFlagString )
                , ( bp::arg("whichOne") ) );
        
        }
        { //::CLAM::FlagsBase::GetNFlags
        
            typedef unsigned int ( ::CLAM::FlagsBase::*GetNFlags_function_type )(  ) const;
            
            FlagsBase_exposer.def( 
                "GetNFlags"
                , bp::pure_virtual( GetNFlags_function_type(&::CLAM::FlagsBase::GetNFlags) ) );
        
        }
        { //::CLAM::FlagsBase::IsSetFlag
        
            typedef bool ( ::CLAM::FlagsBase::*IsSetFlag_function_type )( unsigned int ) const;
            
            FlagsBase_exposer.def( 
                "IsSetFlag"
                , bp::pure_virtual( IsSetFlag_function_type(&::CLAM::FlagsBase::IsSetFlag) )
                , ( bp::arg("whichOne") ) );
        
        }
        { //::CLAM::FlagsBase::LoadFrom
        
            typedef void ( ::CLAM::FlagsBase::*LoadFrom_function_type )( ::CLAM::Storage & ) ;
            typedef void ( FlagsBase_wrapper::*default_LoadFrom_function_type )( ::CLAM::Storage & ) ;
            
            FlagsBase_exposer.def( 
                "LoadFrom"
                , LoadFrom_function_type(&::CLAM::FlagsBase::LoadFrom)
                , default_LoadFrom_function_type(&FlagsBase_wrapper::default_LoadFrom)
                , ( bp::arg("storage") ) );
        
        }
        { //::CLAM::FlagsBase::SetFlag
        
            typedef void ( ::CLAM::FlagsBase::*SetFlag_function_type )( unsigned int,bool ) ;
            
            FlagsBase_exposer.def( 
                "SetFlag"
                , bp::pure_virtual( SetFlag_function_type(&::CLAM::FlagsBase::SetFlag) )
                , ( bp::arg("whichOne"), bp::arg("value") ) );
        
        }
        { //::CLAM::FlagsBase::StoreOn
        
            typedef void ( ::CLAM::FlagsBase::*StoreOn_function_type )( ::CLAM::Storage & ) const;
            typedef void ( FlagsBase_wrapper::*default_StoreOn_function_type )( ::CLAM::Storage & ) const;
            
            FlagsBase_exposer.def( 
                "StoreOn"
                , StoreOn_function_type(&::CLAM::FlagsBase::StoreOn)
                , default_StoreOn_function_type(&FlagsBase_wrapper::default_StoreOn)
                , ( bp::arg("storage") ) );
        
        }
        { //::CLAM::Component::GetClassName
        
            typedef char const * ( ::CLAM::Component::*GetClassName_function_type )(  ) const;
            
            FlagsBase_exposer.def( 
                "GetClassName"
                , bp::pure_virtual( GetClassName_function_type(&::CLAM::Component::GetClassName) ) );
        
        }
        FlagsBase_exposer.def( bp::self_ns::str( bp::self ) );
    }

    bp::class_< Flags_less__4u__grate__wrapper, bp::bases< CLAM::FlagsBase >, boost::noncopyable >( "Flags_less__4u__grate_", bp::init< CLAM::FlagsBase::tFlagValue * >(( bp::arg("names") )) )    
        .def( bp::init< CLAM::FlagsBase::tFlagValue *, CLAM::Flags< 4u > const & >(( bp::arg("names"), bp::arg("t") )) )    
        .def( 
            "DeepCopy"
            , (::CLAM::Component * ( ::CLAM::Flags<4u>::* )(  ) const)(&::CLAM::Flags< 4u >::DeepCopy)
            , (::CLAM::Component * ( Flags_less__4u__grate__wrapper::* )(  ) const)(&Flags_less__4u__grate__wrapper::default_DeepCopy)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetClassName"
            , (char const * ( ::CLAM::Flags<4u>::* )(  ) const)(&::CLAM::Flags< 4u >::GetClassName)
            , (char const * ( Flags_less__4u__grate__wrapper::* )(  ) const)(&Flags_less__4u__grate__wrapper::default_GetClassName) )    
        .def( 
            "GetNFlags"
            , (unsigned int ( ::CLAM::Flags<4u>::* )(  ) const)(&::CLAM::Flags< 4u >::GetNFlags)
            , (unsigned int ( Flags_less__4u__grate__wrapper::* )(  ) const)(&Flags_less__4u__grate__wrapper::default_GetNFlags) )    
        .def( 
            "IsSetFlag"
            , (bool ( Flags_less__4u__grate__wrapper::* )( unsigned int ) const)(&Flags_less__4u__grate__wrapper::IsSetFlag)
            , ( bp::arg("whichOne") ) )    
        .def( 
            "SetFlag"
            , (void ( Flags_less__4u__grate__wrapper::* )( unsigned int,bool ) )(&Flags_less__4u__grate__wrapper::SetFlag)
            , ( bp::arg("whichOne"), bp::arg("value")=(bool)(true) ) )    
        .def( 
            "ShallowCopy"
            , (::CLAM::Component * ( ::CLAM::Flags<4u>::* )(  ) const)(&::CLAM::Flags< 4u >::ShallowCopy)
            , (::CLAM::Component * ( Flags_less__4u__grate__wrapper::* )(  ) const)(&Flags_less__4u__grate__wrapper::default_ShallowCopy)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "Species"
            , bp::pure_virtual( (::CLAM::Component * ( ::CLAM::Flags<4u>::* )(  ) const)(&::CLAM::Flags< 4u >::Species) )
            , bp::return_value_policy< bp::reference_existing_object >() );

    bp::class_< FlattenedNetwork_wrapper >( "FlattenedNetwork" )    
        .def( bp::init< >() )    
        .def( 
            "AddFlowControl"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::CLAM::FlowControl * ) )( &::CLAM::FlattenedNetwork::AddFlowControl )
            , ( bp::arg("arg0") ) )    
        .def( 
            "AddProcessing"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::CLAM::Processing * ) )(&::CLAM::FlattenedNetwork::AddProcessing)
            , (void ( FlattenedNetwork_wrapper::* )( ::std::string const &,::CLAM::Processing * ) )(&FlattenedNetwork_wrapper::default_AddProcessing)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "AddProcessing"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::AddProcessing)
            , (void ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_AddProcessing)
            , ( bp::arg("name"), bp::arg("key") ) )    
        .def( 
            "AddProcessing"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) )(&::CLAM::FlattenedNetwork::AddProcessing)
            , (::std::string ( FlattenedNetwork_wrapper::* )( ::std::string const & ) )(&FlattenedNetwork_wrapper::default_AddProcessing)
            , ( bp::arg("key") ) )    
        .def( 
            "BackendBufferSize"
            , (unsigned int ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::BackendBufferSize)
            , (unsigned int ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_BackendBufferSize) )    
        .def( 
            "BackendSampleRate"
            , (unsigned int ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::BackendSampleRate)
            , (unsigned int ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_BackendSampleRate) )    
        .def( 
            "BeginProcessings"
            , (::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::BeginProcessings)
            , (::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_BeginProcessings) )    
        .def( 
            "BeginProcessings"
            , (::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::BeginProcessings)
            , (::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_BeginProcessings) )    
        .def( 
            "Clear"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::Clear)
            , (void ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_Clear) )    
        .def( 
            "ConfigureProcessing"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::CLAM::ProcessingConfig const & ) )(&::CLAM::FlattenedNetwork::ConfigureProcessing)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::CLAM::ProcessingConfig const & ) )(&FlattenedNetwork_wrapper::default_ConfigureProcessing)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "ConnectControls"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::ConnectControls)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_ConnectControls)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "ConnectPorts"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::ConnectPorts)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_ConnectPorts)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "DisconnectControls"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::DisconnectControls)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_DisconnectControls)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "DisconnectPorts"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::DisconnectPorts)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_DisconnectPorts)
            , ( bp::arg("arg0"), bp::arg("arg1") ) )    
        .def( 
            "Do"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )( &::CLAM::FlattenedNetwork::Do ) )    
        .def( 
            "EndProcessings"
            , (::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::EndProcessings)
            , (::std::_Rb_tree_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_EndProcessings) )    
        .def( 
            "EndProcessings"
            , (::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::EndProcessings)
            , (::std::_Rb_tree_const_iterator< std::pair< const std::basic_string< char, std::char_traits< char >, std::allocator< char > >, CLAM::Processing* > > ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_EndProcessings) )    
        .def( 
            "GetAndClearGeometries"
            , (::std::map< std::string, CLAM::BaseNetwork::Geometry > const ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::GetAndClearGeometries)
            , (::std::map< std::string, CLAM::BaseNetwork::Geometry > const ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_GetAndClearGeometries) )    
        .def( 
            "GetClassName"
            , (char const * ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::GetClassName)
            , (char const * ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_GetClassName) )    
        .def( 
            "GetConfigurationErrors"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::GetConfigurationErrors)
            , (::std::string ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_GetConfigurationErrors) )    
        .def( 
            "GetConnectorIdentifier"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetConnectorIdentifier)
            , (::std::string ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_GetConnectorIdentifier)
            , ( bp::arg("arg0") ) )    
        .def( 
            "GetInControlByCompleteName"
            , (::CLAM::InControl & ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetInControlByCompleteName)
            , ( bp::arg("arg0") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetInControlsConnectedTo"
            , (::std::list< std::string > ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetInControlsConnectedTo)
            , (::std::list< std::string > ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_GetInControlsConnectedTo)
            , ( bp::arg("arg0") ) )    
        .def( 
            "GetInPortByCompleteName"
            , (::CLAM::InPortBase & ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetInPortByCompleteName)
            , ( bp::arg("arg0") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetInPortsConnectedTo"
            , (::std::list< std::string > ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetInPortsConnectedTo)
            , (::std::list< std::string > ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_GetInPortsConnectedTo)
            , ( bp::arg("arg0") ) )    
        .def( 
            "GetInPortsConnectedTo"
            , (::std::list< CLAM::InPortBase* > ( ::CLAM::FlattenedNetwork::* )( ::CLAM::OutPortBase & ) const)(&::CLAM::FlattenedNetwork::GetInPortsConnectedTo)
            , (::std::list< CLAM::InPortBase* > ( FlattenedNetwork_wrapper::* )( ::CLAM::OutPortBase & ) const)(&FlattenedNetwork_wrapper::default_GetInPortsConnectedTo)
            , ( bp::arg("arg0") ) )    
        .def( 
            "GetName"
            , (::std::string const & ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::GetName)
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetNetworkId"
            , (::std::string const & ( ::CLAM::FlattenedNetwork::* )( ::CLAM::Processing const * ) const)(&::CLAM::FlattenedNetwork::GetNetworkId)
            , ( bp::arg("proc") )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetOutControlByCompleteName"
            , (::CLAM::OutControl & ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetOutControlByCompleteName)
            , ( bp::arg("arg0") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetOutPortByCompleteName"
            , (::CLAM::OutPortBase & ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetOutPortByCompleteName)
            , ( bp::arg("arg0") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetProcessing"
            , (::CLAM::Processing & ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetProcessing)
            , ( bp::arg("name") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetProcessingIdentifier"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetProcessingIdentifier)
            , (::std::string ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_GetProcessingIdentifier)
            , ( bp::arg("arg0") ) )    
        .def( 
            "GetUnconnectedInPorts"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::GetUnconnectedInPorts)
            , (::std::string ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_GetUnconnectedInPorts) )    
        .def( 
            "GetUnusedName"
            , (::std::string ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::GetUnusedName)
            , (::std::string ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_GetUnusedName)
            , ( bp::arg("prefix") ) )    
        .def( 
            "HasMisconfiguredProcessings"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::HasMisconfiguredProcessings)
            , (bool ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_HasMisconfiguredProcessings) )    
        .def( 
            "HasProcessing"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) const)(&::CLAM::FlattenedNetwork::HasProcessing)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const & ) const)(&FlattenedNetwork_wrapper::default_HasProcessing)
            , ( bp::arg("name") ) )    
        .def( 
            "HasSyncSource"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::HasSyncSource)
            , (bool ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_HasSyncSource) )    
        .def( 
            "HasUnconnectedInPorts"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::HasUnconnectedInPorts)
            , (bool ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_HasUnconnectedInPorts) )    
        .def( 
            "IsEmpty"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::IsEmpty)
            , (bool ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_IsEmpty) )    
        .def( 
            "IsReady"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)(&::CLAM::FlattenedNetwork::IsReady)
            , (bool ( FlattenedNetwork_wrapper::* )(  ) const)(&FlattenedNetwork_wrapper::default_IsReady) )    
        .def( 
            "IsStopped"
            , (bool ( ::CLAM::FlattenedNetwork::* )(  ) const)( &::CLAM::FlattenedNetwork::IsStopped ) )    
        .def( 
            "LoadFrom"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::CLAM::Storage & ) )(&::CLAM::FlattenedNetwork::LoadFrom)
            , (void ( FlattenedNetwork_wrapper::* )( ::CLAM::Storage & ) )(&FlattenedNetwork_wrapper::default_LoadFrom)
            , ( bp::arg("storage") ) )    
        .def( 
            "ReconfigureAllProcessings"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::ReconfigureAllProcessings)
            , (void ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_ReconfigureAllProcessings) )    
        .def( 
            "RemoveProcessing"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) )(&::CLAM::FlattenedNetwork::RemoveProcessing)
            , (void ( FlattenedNetwork_wrapper::* )( ::std::string const & ) )(&FlattenedNetwork_wrapper::default_RemoveProcessing)
            , ( bp::arg("arg0") ) )    
        .def( 
            "RenameProcessing"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::string const &,::std::string const & ) )(&::CLAM::FlattenedNetwork::RenameProcessing)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::string const &,::std::string const & ) )(&FlattenedNetwork_wrapper::default_RenameProcessing)
            , ( bp::arg("oldName"), bp::arg("newName") ) )    
        .def( 
            "SetName"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::std::string const & ) )(&::CLAM::FlattenedNetwork::SetName)
            , (void ( FlattenedNetwork_wrapper::* )( ::std::string const & ) )(&FlattenedNetwork_wrapper::default_SetName)
            , ( bp::arg("name") ) )    
        .def( 
            "SetPlayer"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::CLAM::NetworkPlayer * ) )( &::CLAM::FlattenedNetwork::SetPlayer )
            , ( bp::arg("player") ) )    
        .def( 
            "SetProcessingsGeometries"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::map< std::string, CLAM::BaseNetwork::Geometry > const & ) )(&::CLAM::FlattenedNetwork::SetProcessingsGeometries)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::map< std::string, CLAM::BaseNetwork::Geometry > const & ) )(&FlattenedNetwork_wrapper::default_SetProcessingsGeometries)
            , ( bp::arg("processingsGeometries") ) )    
        .def( 
            "Start"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )( &::CLAM::FlattenedNetwork::Start ) )    
        .def( 
            "Stop"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )( &::CLAM::FlattenedNetwork::Stop ) )    
        .def( 
            "StoreOn"
            , (void ( ::CLAM::FlattenedNetwork::* )( ::CLAM::Storage & ) const)(&::CLAM::FlattenedNetwork::StoreOn)
            , (void ( FlattenedNetwork_wrapper::* )( ::CLAM::Storage & ) const)(&FlattenedNetwork_wrapper::default_StoreOn)
            , ( bp::arg("storage") ) )    
        .def( 
            "UpdateSelections"
            , (bool ( ::CLAM::FlattenedNetwork::* )( ::std::list< std::string > const & ) )(&::CLAM::FlattenedNetwork::UpdateSelections)
            , (bool ( FlattenedNetwork_wrapper::* )( ::std::list< std::string > const & ) )(&FlattenedNetwork_wrapper::default_UpdateSelections)
            , ( bp::arg("processingsNamesList") ) )    
        .def( 
            "setPasteMode"
            , (void ( ::CLAM::FlattenedNetwork::* )(  ) )(&::CLAM::FlattenedNetwork::setPasteMode)
            , (void ( FlattenedNetwork_wrapper::* )(  ) )(&FlattenedNetwork_wrapper::default_setPasteMode) );

    bp::class_< FlowControl_wrapper, boost::noncopyable >( "FlowControl" )    
        .def( bp::init< >() )    
        .def( 
            "AttachToNetwork"
            , (void ( ::CLAM::FlowControl::* )( ::CLAM::Network * ) )(&::CLAM::FlowControl::AttachToNetwork)
            , (void ( FlowControl_wrapper::* )( ::CLAM::Network * ) )(&FlowControl_wrapper::default_AttachToNetwork)
            , ( bp::arg("arg0") ) )    
        .def( 
            "Do"
            , bp::pure_virtual( (void ( ::CLAM::FlowControl::* )(  ) )(&::CLAM::FlowControl::Do) ) )    
        .def( 
            "HasNetworkTopologyChanged"
            , (bool ( FlowControl_wrapper::* )(  ) const)(&FlowControl_wrapper::HasNetworkTopologyChanged) )    
        .def( 
            "NetworkTopologyChanged"
            , (void ( ::CLAM::FlowControl::* )(  ) )( &::CLAM::FlowControl::NetworkTopologyChanged ) )    
        .def( 
            "ProcessingAddedToNetwork"
            , (void ( ::CLAM::FlowControl::* )( ::CLAM::Processing & ) )(&::CLAM::FlowControl::ProcessingAddedToNetwork)
            , (void ( FlowControl_wrapper::* )( ::CLAM::Processing & ) )(&FlowControl_wrapper::default_ProcessingAddedToNetwork)
            , ( bp::arg("added") ) )    
        .def( 
            "ProcessingConfigured"
            , (void ( ::CLAM::FlowControl::* )( ::CLAM::Processing & ) )( &::CLAM::FlowControl::ProcessingConfigured )
            , ( bp::arg("configured") ) )    
        .def( 
            "ProcessingRemovedFromNetwork"
            , (void ( ::CLAM::FlowControl::* )( ::CLAM::Processing & ) )(&::CLAM::FlowControl::ProcessingRemovedFromNetwork)
            , (void ( FlowControl_wrapper::* )( ::CLAM::Processing & ) )(&FlowControl_wrapper::default_ProcessingRemovedFromNetwork)
            , ( bp::arg("removed") ) );

    bp::class_< CLAM::IllegalValue >( "IllegalValue", bp::init< CLAM::IllegalValue const & >(( bp::arg("e") )) )    
        .def( bp::init< std::string const & >(( bp::arg("s") )) )    
        .def_readwrite( "msg", &CLAM::IllegalValue::msg );

    bp::implicitly_convertible< std::string const &, CLAM::IllegalValue >();

    bp::class_< InControl_wrapper >( "InControl", bp::init< std::string const &, bp::optional< CLAM::Processing *, bool > >(( bp::arg("name"), bp::arg("parent")=bp::object(), bp::arg("publish")=(bool const)(true) )) )    
        .def( 
            "DefaultValue"
            , (::CLAM::TControlData ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::DefaultValue ) )    
        .def( 
            "DoControl"
            , (int ( ::CLAM::InControl::* )( ::CLAM::TControlData ) )(&::CLAM::InControl::DoControl)
            , (int ( InControl_wrapper::* )( ::CLAM::TControlData ) )(&InControl_wrapper::default_DoControl)
            , ( bp::arg("val") ) )    
        .def( 
            "GetLastValue"
            , (::CLAM::TControlData const & ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::GetLastValue )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetLastValueAsBoolean"
            , (bool ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::GetLastValueAsBoolean ) )    
        .def( 
            "GetLastValueAsInteger"
            , (int ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::GetLastValueAsInteger ) )    
        .def( 
            "GetName"
            , (::std::string const & ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::GetName )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetProcessing"
            , (::CLAM::Processing * ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::GetProcessing )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "IsBounded"
            , (bool ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::IsBounded ) )    
        .def( 
            "IsConnected"
            , (bool ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::IsConnected ) )    
        .def( 
            "IsConnectedTo"
            , (bool ( ::CLAM::InControl::* )( ::CLAM::OutControl & ) )( &::CLAM::InControl::IsConnectedTo )
            , ( bp::arg("arg0") ) )    
        .def( 
            "LowerBound"
            , (::CLAM::TControlData ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::LowerBound ) )    
        .def( 
            "OutControlInterface_AddLink"
            , (void ( ::CLAM::InControl::* )( ::CLAM::OutControl & ) )( &::CLAM::InControl::OutControlInterface_AddLink )
            , ( bp::arg("outControl") ) )    
        .def( 
            "OutControlInterface_RemoveLink"
            , (void ( ::CLAM::InControl::* )( ::CLAM::OutControl & ) )( &::CLAM::InControl::OutControlInterface_RemoveLink )
            , ( bp::arg("outControl") ) )    
        .def( 
            "SetBounds"
            , (void ( ::CLAM::InControl::* )( ::CLAM::TControlData,::CLAM::TControlData ) )( &::CLAM::InControl::SetBounds )
            , ( bp::arg("lower"), bp::arg("upper") ) )    
        .def( 
            "SetDefaultValue"
            , (void ( ::CLAM::InControl::* )( ::CLAM::TControlData ) )( &::CLAM::InControl::SetDefaultValue )
            , ( bp::arg("val") ) )    
        .def( 
            "UpperBound"
            , (::CLAM::TControlData ( ::CLAM::InControl::* )(  ) const)( &::CLAM::InControl::UpperBound ) );

    bp::class_< CLAM::Network, bp::bases< CLAM::FlattenedNetwork > >( "Network" )    
        .def( bp::init< >() );

    { //::CLAM::NetworkPlayer
        typedef bp::class_< NetworkPlayer_wrapper, boost::noncopyable > NetworkPlayer_exposer_t;
        NetworkPlayer_exposer_t NetworkPlayer_exposer = NetworkPlayer_exposer_t( "NetworkPlayer" );
        bp::scope NetworkPlayer_scope( NetworkPlayer_exposer );
        NetworkPlayer_exposer.def( bp::init< >() );
        { //::CLAM::NetworkPlayer::BackendBufferSize
        
            typedef unsigned int ( ::CLAM::NetworkPlayer::*BackendBufferSize_function_type )(  ) ;
            typedef unsigned int ( NetworkPlayer_wrapper::*default_BackendBufferSize_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "BackendBufferSize"
                , BackendBufferSize_function_type(&::CLAM::NetworkPlayer::BackendBufferSize)
                , default_BackendBufferSize_function_type(&NetworkPlayer_wrapper::default_BackendBufferSize) );
        
        }
        { //::CLAM::NetworkPlayer::BackendSampleRate
        
            typedef unsigned int ( ::CLAM::NetworkPlayer::*BackendSampleRate_function_type )(  ) ;
            typedef unsigned int ( NetworkPlayer_wrapper::*default_BackendSampleRate_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "BackendSampleRate"
                , BackendSampleRate_function_type(&::CLAM::NetworkPlayer::BackendSampleRate)
                , default_BackendSampleRate_function_type(&NetworkPlayer_wrapper::default_BackendSampleRate) );
        
        }
        { //::CLAM::NetworkPlayer::CollectSourcesAndSinks
        
            typedef void ( NetworkPlayer_wrapper::*CollectSourcesAndSinks_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "CollectSourcesAndSinks"
                , CollectSourcesAndSinks_function_type( &NetworkPlayer_wrapper::CollectSourcesAndSinks ) );
        
        }
        { //::CLAM::NetworkPlayer::GetAudioSinks
        
            typedef ::std::vector< CLAM::AudioSink* > const & ( NetworkPlayer_wrapper::*GetAudioSinks_function_type )(  ) const;
            
            NetworkPlayer_exposer.def( 
                "GetAudioSinks"
                , GetAudioSinks_function_type( &NetworkPlayer_wrapper::GetAudioSinks )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::CLAM::NetworkPlayer::GetAudioSinks
        
            typedef ::std::vector< CLAM::AudioSink* > & ( NetworkPlayer_wrapper::*GetAudioSinks_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "GetAudioSinks"
                , GetAudioSinks_function_type( &NetworkPlayer_wrapper::GetAudioSinks )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::NetworkPlayer::GetAudioSources
        
            typedef ::std::vector< CLAM::AudioSource* > const & ( NetworkPlayer_wrapper::*GetAudioSources_function_type )(  ) const;
            
            NetworkPlayer_exposer.def( 
                "GetAudioSources"
                , GetAudioSources_function_type( &NetworkPlayer_wrapper::GetAudioSources )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::CLAM::NetworkPlayer::GetAudioSources
        
            typedef ::std::vector< CLAM::AudioSource* > & ( NetworkPlayer_wrapper::*GetAudioSources_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "GetAudioSources"
                , GetAudioSources_function_type( &NetworkPlayer_wrapper::GetAudioSources )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::NetworkPlayer::GetNetwork
        
            typedef ::CLAM::Network & ( NetworkPlayer_wrapper::*GetNetwork_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "GetNetwork"
                , GetNetwork_function_type( &NetworkPlayer_wrapper::GetNetwork )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CLAM::NetworkPlayer::Init
        
            typedef void ( ::CLAM::NetworkPlayer::*Init_function_type )(  ) ;
            typedef void ( NetworkPlayer_wrapper::*default_Init_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "Init"
                , Init_function_type(&::CLAM::NetworkPlayer::Init)
                , default_Init_function_type(&NetworkPlayer_wrapper::default_Init) );
        
        }
        { //::CLAM::NetworkPlayer::IsStopped
        
            typedef bool ( ::CLAM::NetworkPlayer::*IsStopped_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "IsStopped"
                , IsStopped_function_type( &::CLAM::NetworkPlayer::IsStopped ) );
        
        }
        { //::CLAM::NetworkPlayer::IsWorking
        
            typedef bool ( ::CLAM::NetworkPlayer::*IsWorking_function_type )(  ) const;
            
            NetworkPlayer_exposer.def( 
                "IsWorking"
                , bp::pure_virtual( IsWorking_function_type(&::CLAM::NetworkPlayer::IsWorking) ) );
        
        }
        { //::CLAM::NetworkPlayer::NonWorkingReason
        
            typedef ::std::string ( ::CLAM::NetworkPlayer::*NonWorkingReason_function_type )(  ) const;
            
            NetworkPlayer_exposer.def( 
                "NonWorkingReason"
                , bp::pure_virtual( NonWorkingReason_function_type(&::CLAM::NetworkPlayer::NonWorkingReason) ) );
        
        }
        { //::CLAM::NetworkPlayer::SetNetworkBackLink
        
            typedef void ( ::CLAM::NetworkPlayer::*SetNetworkBackLink_function_type )( ::CLAM::Network & ) ;
            
            NetworkPlayer_exposer.def( 
                "SetNetworkBackLink"
                , SetNetworkBackLink_function_type( &::CLAM::NetworkPlayer::SetNetworkBackLink )
                , ( bp::arg("net") ) );
        
        }
        { //::CLAM::NetworkPlayer::SetStopped
        
            typedef void ( NetworkPlayer_wrapper::*SetStopped_function_type )( bool const ) ;
            
            NetworkPlayer_exposer.def( 
                "SetStopped"
                , SetStopped_function_type( &NetworkPlayer_wrapper::SetStopped )
                , ( bp::arg("val") ) );
        
        }
        { //::CLAM::NetworkPlayer::SourcesAndSinksToString
        
            typedef ::std::string ( ::CLAM::NetworkPlayer::*SourcesAndSinksToString_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "SourcesAndSinksToString"
                , SourcesAndSinksToString_function_type( &::CLAM::NetworkPlayer::SourcesAndSinksToString ) );
        
        }
        { //::CLAM::NetworkPlayer::Start
        
            typedef void ( ::CLAM::NetworkPlayer::*Start_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "Start"
                , bp::pure_virtual( Start_function_type(&::CLAM::NetworkPlayer::Start) ) );
        
        }
        { //::CLAM::NetworkPlayer::Stop
        
            typedef void ( ::CLAM::NetworkPlayer::*Stop_function_type )(  ) ;
            
            NetworkPlayer_exposer.def( 
                "Stop"
                , bp::pure_virtual( Stop_function_type(&::CLAM::NetworkPlayer::Stop) ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< CLAM::NetworkPlayer > >();
    }

    bp::class_< OutControl_wrapper >( "OutControl", bp::init< std::string const &, bp::optional< CLAM::Processing *, bool > >(( bp::arg("name"), bp::arg("parent")=bp::object(), bp::arg("publish")=(bool const)(true) )) )    
        .def( 
            "AddLink"
            , (void ( ::CLAM::OutControl::* )( ::CLAM::InControl & ) )(&::CLAM::OutControl::AddLink)
            , (void ( OutControl_wrapper::* )( ::CLAM::InControl & ) )(&OutControl_wrapper::default_AddLink)
            , ( bp::arg("in") ) )    
        .def( 
            "BeginInControlsConnected"
            , (::std::_List_iterator< CLAM::InControl* > ( ::CLAM::OutControl::* )(  ) )( &::CLAM::OutControl::BeginInControlsConnected ) )    
        .def( 
            "EndInControlsConnected"
            , (::std::_List_iterator< CLAM::InControl* > ( ::CLAM::OutControl::* )(  ) )( &::CLAM::OutControl::EndInControlsConnected ) )    
        .def( 
            "GetName"
            , (::std::string const & ( ::CLAM::OutControl::* )(  ) const)( &::CLAM::OutControl::GetName )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "GetProcessing"
            , (::CLAM::Processing * ( ::CLAM::OutControl::* )(  ) const)( &::CLAM::OutControl::GetProcessing )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "IsConnected"
            , (bool ( ::CLAM::OutControl::* )(  ) )( &::CLAM::OutControl::IsConnected ) )    
        .def( 
            "IsConnectedTo"
            , (bool ( ::CLAM::OutControl::* )( ::CLAM::InControl & ) )( &::CLAM::OutControl::IsConnectedTo )
            , ( bp::arg("arg0") ) )    
        .def( 
            "RemoveLink"
            , (void ( ::CLAM::OutControl::* )( ::CLAM::InControl & ) )( &::CLAM::OutControl::RemoveLink )
            , ( bp::arg("in") ) )    
        .def( 
            "SendControl"
            , (int ( ::CLAM::OutControl::* )( ::CLAM::TControlData ) )( &::CLAM::OutControl::SendControl )
            , ( bp::arg("val") ) )    
        .def( 
            "SendControlAsBoolean"
            , (int ( ::CLAM::OutControl::* )( bool ) )( &::CLAM::OutControl::SendControlAsBoolean )
            , ( bp::arg("booleanValue") ) )    
        .def( 
            "SendControlAsInteger"
            , (int ( ::CLAM::OutControl::* )( int ) )( &::CLAM::OutControl::SendControlAsInteger )
            , ( bp::arg("intvalue") ) );

    bp::class_< ProcessingConfig_wrapper, boost::noncopyable >( "ProcessingConfig", bp::init< int >(( bp::arg("n") )) )    
        .def( bp::init< CLAM::ProcessingConfig const &, bp::optional< bool, bool > >(( bp::arg("prototype"), bp::arg("shareData")=(bool)(false), bp::arg("deep")=(bool)(true) )) )    
        .def( 
            "GetClassName"
            , (char const * ( ::CLAM::ProcessingConfig::* )(  ) const)(&::CLAM::ProcessingConfig::GetClassName)
            , (char const * ( ProcessingConfig_wrapper::* )(  ) const)(&ProcessingConfig_wrapper::default_GetClassName) )    
        .def( 
            "GetDynamicTypeCopy"
            , (::CLAM::DynamicType & ( ProcessingConfig_wrapper::* )( bool const,bool const ) const)(&ProcessingConfig_wrapper::GetDynamicTypeCopy)
            , ( bp::arg("shareData")=(bool const)(false), bp::arg("deep")=(bool const)(false) )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetTypeId"
            , bp::pure_virtual( (::std::type_info const & ( ::CLAM::DynamicType::* )( unsigned int ) const)(&::CLAM::DynamicType::GetTypeId) )
            , ( bp::arg("i") )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "LoadDynAttributes"
            , (void ( ProcessingConfig_wrapper::* )( ::CLAM::Storage & ) )(&ProcessingConfig_wrapper::LoadDynAttributes)
            , ( bp::arg("s") ) )    
        .def( 
            "StoreDynAttributes"
            , (void ( ProcessingConfig_wrapper::* )( ::CLAM::Storage & ) const)(&ProcessingConfig_wrapper::StoreDynAttributes)
            , ( bp::arg("s") ) );

    bp::class_< ProcessingData_wrapper, boost::noncopyable >( "ProcessingData", bp::init< int >(( bp::arg("n") )) )    
        .def( bp::init< CLAM::ProcessingData const &, bp::optional< bool, bool > >(( bp::arg("prototype"), bp::arg("shareData")=(bool)(false), bp::arg("deep")=(bool)(true) )) )    
        .def( 
            "GetClassName"
            , bp::pure_virtual( (char const * ( ::CLAM::DynamicType::* )(  ) const)(&::CLAM::DynamicType::GetClassName) ) )    
        .def( 
            "GetDynamicTypeCopy"
            , (::CLAM::DynamicType & ( ProcessingData_wrapper::* )( bool const,bool const ) const)(&ProcessingData_wrapper::GetDynamicTypeCopy)
            , ( bp::arg("shareData")=(bool const)(false), bp::arg("deep")=(bool const)(false) )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetTypeId"
            , bp::pure_virtual( (::std::type_info const & ( ::CLAM::DynamicType::* )( unsigned int ) const)(&::CLAM::DynamicType::GetTypeId) )
            , ( bp::arg("i") )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "LoadDynAttributes"
            , (void ( ProcessingData_wrapper::* )( ::CLAM::Storage & ) )(&ProcessingData_wrapper::LoadDynAttributes)
            , ( bp::arg("s") ) )    
        .def( 
            "StoreDynAttributes"
            , (void ( ProcessingData_wrapper::* )( ::CLAM::Storage & ) const)(&ProcessingData_wrapper::StoreDynAttributes)
            , ( bp::arg("s") ) );

    bp::class_< ProcessingDataConfig_wrapper, boost::noncopyable >( "ProcessingDataConfig", bp::init< int >(( bp::arg("n") )) )    
        .def( bp::init< CLAM::ProcessingDataConfig const &, bp::optional< bool, bool > >(( bp::arg("prototype"), bp::arg("shareData")=(bool)(false), bp::arg("deep")=(bool)(true) )) )    
        .def( 
            "GetClassName"
            , bp::pure_virtual( (char const * ( ::CLAM::DynamicType::* )(  ) const)(&::CLAM::DynamicType::GetClassName) ) )    
        .def( 
            "GetDynamicTypeCopy"
            , (::CLAM::DynamicType & ( ProcessingDataConfig_wrapper::* )( bool const,bool const ) const)(&ProcessingDataConfig_wrapper::GetDynamicTypeCopy)
            , ( bp::arg("shareData")=(bool const)(false), bp::arg("deep")=(bool const)(false) )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "GetTypeId"
            , bp::pure_virtual( (::std::type_info const & ( ::CLAM::DynamicType::* )( unsigned int ) const)(&::CLAM::DynamicType::GetTypeId) )
            , ( bp::arg("i") )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "LoadDynAttributes"
            , (void ( ProcessingDataConfig_wrapper::* )( ::CLAM::Storage & ) )(&ProcessingDataConfig_wrapper::LoadDynAttributes)
            , ( bp::arg("s") ) )    
        .def( 
            "StoreDynAttributes"
            , (void ( ProcessingDataConfig_wrapper::* )( ::CLAM::Storage & ) const)(&ProcessingDataConfig_wrapper::StoreDynAttributes)
            , ( bp::arg("s") ) );

    bp::class_< CLAM::ProcessingDataPlugin, boost::noncopyable >( "ProcessingDataPlugin", bp::no_init )    
        .def( 
            "color"
            , (::std::string const & ( ::CLAM::ProcessingDataPlugin::* )(  ) const)( &::CLAM::ProcessingDataPlugin::color )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "colorFor"
            , (::std::string (*)( ::std::type_info const & ))( &::CLAM::ProcessingDataPlugin::colorFor )
            , ( bp::arg("type") ) )    
        .def( 
            "displayName"
            , (::std::string const & ( ::CLAM::ProcessingDataPlugin::* )(  ) const)( &::CLAM::ProcessingDataPlugin::displayName )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "displayNameFor"
            , (::std::string (*)( ::std::type_info const & ))( &::CLAM::ProcessingDataPlugin::displayNameFor )
            , ( bp::arg("type") ) )    
        .def( 
            "lookUp"
            , (::CLAM::ProcessingDataPlugin * (*)( ::std::type_info const & ))( &::CLAM::ProcessingDataPlugin::lookUp )
            , ( bp::arg("type") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "name"
            , (::std::string const & ( ::CLAM::ProcessingDataPlugin::* )(  ) const)( &::CLAM::ProcessingDataPlugin::name )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "types"
            , (::std::list< std::string > (*)(  ))( &::CLAM::ProcessingDataPlugin::types ) )    
        .staticmethod( "colorFor" )    
        .staticmethod( "displayNameFor" )    
        .staticmethod( "lookUp" )    
        .staticmethod( "types" );

    { //::CLAM::SpecTypeFlags
        typedef bp::class_< SpecTypeFlags_wrapper, bp::bases< CLAM::Flags< 4u > > > SpecTypeFlags_exposer_t;
        SpecTypeFlags_exposer_t SpecTypeFlags_exposer = SpecTypeFlags_exposer_t( "SpecTypeFlags" );
        bp::scope SpecTypeFlags_scope( SpecTypeFlags_exposer );
        bp::enum_< CLAM::SpecTypeFlags::tFlags>("tFlags")
            .value("eComplex", CLAM::SpecTypeFlags::eComplex)
            .value("ePolar", CLAM::SpecTypeFlags::ePolar)
            .value("eMagPhase", CLAM::SpecTypeFlags::eMagPhase)
            .value("eMagPhaseBPF", CLAM::SpecTypeFlags::eMagPhaseBPF)
            .export_values()
            ;
        SpecTypeFlags_exposer.def( bp::init< >() );
        SpecTypeFlags_exposer.def( bp::init< CLAM::SpecTypeFlags const & >(( bp::arg("t") )) );
        { //::CLAM::SpecTypeFlags::Species
        
            typedef ::CLAM::Component * ( ::CLAM::SpecTypeFlags::*Species_function_type )(  ) const;
            typedef ::CLAM::Component * ( SpecTypeFlags_wrapper::*default_Species_function_type )(  ) const;
            
            SpecTypeFlags_exposer.def( 
                "Species"
                , Species_function_type(&::CLAM::SpecTypeFlags::Species)
                , default_Species_function_type(&SpecTypeFlags_wrapper::default_Species)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        SpecTypeFlags_exposer.def_readwrite( "bComplex", &CLAM::SpecTypeFlags::bComplex );
        SpecTypeFlags_exposer.def_readwrite( "bMagPhase", &CLAM::SpecTypeFlags::bMagPhase );
        SpecTypeFlags_exposer.def_readwrite( "bMagPhaseBPF", &CLAM::SpecTypeFlags::bMagPhaseBPF );
        SpecTypeFlags_exposer.def_readwrite( "bPolar", &CLAM::SpecTypeFlags::bPolar );
        SpecTypeFlags_exposer.def_readwrite( "sDefault", CLAM::SpecTypeFlags::sDefault );
        { //::CLAM::Flags< 4u >::IsSetFlag
        
            typedef CLAM::SpecTypeFlags exported_class_t;
            typedef bool ( SpecTypeFlags_wrapper::*IsSetFlag_function_type )( unsigned int ) const;
            
            SpecTypeFlags_exposer.def( 
                "IsSetFlag"
                , IsSetFlag_function_type( &SpecTypeFlags_wrapper::IsSetFlag )
                , ( bp::arg("whichOne") ) );
        
        }
        { //::CLAM::Flags< 4u >::SetFlag
        
            typedef CLAM::SpecTypeFlags exported_class_t;
            typedef void ( SpecTypeFlags_wrapper::*SetFlag_function_type )( unsigned int,bool ) ;
            
            SpecTypeFlags_exposer.def( 
                "SetFlag"
                , SetFlag_function_type( &SpecTypeFlags_wrapper::SetFlag )
                , ( bp::arg("whichOne"), bp::arg("value")=(bool)(true) ) );
        
        }
    }

    bp::class_< Storage_wrapper, boost::noncopyable >( "Storage" )    
        .def( 
            "Load"
            , bp::pure_virtual( (bool ( ::CLAM::Storage::* )( ::CLAM::Storable & ) )(&::CLAM::Storage::Load) )
            , ( bp::arg("object") ) )    
        .def( 
            "Store"
            , bp::pure_virtual( (void ( ::CLAM::Storage::* )( ::CLAM::Storable const & ) )(&::CLAM::Storage::Store) )
            , ( bp::arg("object") ) );

    bp::class_< XmlStorage_wrapper, bp::bases< CLAM::Storage > >( "XmlStorage" )    
        .def( bp::init< >() )    
        .def( 
            "AppendToDocument"
            , (void (*)( ::CLAM::Component const &,::std::string const &,::std::string const & ))( &::CLAM::XmlStorage::AppendToDocument )
            , ( bp::arg("obj"), bp::arg("xpath"), bp::arg("filename") ) )    
        .def( 
            "Create"
            , (void ( ::CLAM::XmlStorage::* )( ::std::string const & ) )( &::CLAM::XmlStorage::Create )
            , ( bp::arg("name") ) )    
        .def( 
            "Dump"
            , (void (*)( ::CLAM::Component const &,::std::string const &,::std::ostream &,bool ))( &::CLAM::XmlStorage::Dump )
            , ( bp::arg("obj"), bp::arg("rootName"), bp::arg("os"), bp::arg("indentate")=(bool)(true) ) )    
        .def( 
            "Dump"
            , (void (*)( ::CLAM::Component const &,::std::string const &,::std::string const & ))( &::CLAM::XmlStorage::Dump )
            , ( bp::arg("obj"), bp::arg("rootName"), bp::arg("filename") ) )    
        .def( 
            "DumpObject"
            , (void ( ::CLAM::XmlStorage::* )( ::CLAM::Component const & ) )( &::CLAM::XmlStorage::DumpObject )
            , ( bp::arg("component") ) )    
        .def( 
            "Load"
            , (bool ( ::CLAM::XmlStorage::* )( ::CLAM::Storable & ) )(&::CLAM::XmlStorage::Load)
            , (bool ( XmlStorage_wrapper::* )( ::CLAM::Storable & ) )(&XmlStorage_wrapper::default_Load)
            , ( bp::arg("storable") ) )    
        .def( 
            "Read"
            , (void ( ::CLAM::XmlStorage::* )( ::std::istream & ) )( &::CLAM::XmlStorage::Read )
            , ( bp::arg("is") ) )    
        .def( 
            "Restore"
            , (void (*)( ::CLAM::Component &,::std::istream & ))( &::CLAM::XmlStorage::Restore )
            , ( bp::arg("obj"), bp::arg("is") ) )    
        .def( 
            "Restore"
            , (void (*)( ::CLAM::Component &,::std::string const & ))( &::CLAM::XmlStorage::Restore )
            , ( bp::arg("obj"), bp::arg("filename") ) )    
        .def( 
            "RestoreFromFragment"
            , (void (*)( ::CLAM::Component &,::std::string const &,::std::istream & ))( &::CLAM::XmlStorage::RestoreFromFragment )
            , ( bp::arg("obj"), bp::arg("path"), bp::arg("is") ) )    
        .def( 
            "RestoreObject"
            , (void ( ::CLAM::XmlStorage::* )( ::CLAM::Component & ) )( &::CLAM::XmlStorage::RestoreObject )
            , ( bp::arg("component") ) )    
        .def( 
            "Select"
            , (void ( ::CLAM::XmlStorage::* )( ::std::string const & ) )( &::CLAM::XmlStorage::Select )
            , ( bp::arg("path") ) )    
        .def( 
            "Store"
            , (void ( ::CLAM::XmlStorage::* )( ::CLAM::Storable const & ) )(&::CLAM::XmlStorage::Store)
            , (void ( XmlStorage_wrapper::* )( ::CLAM::Storable const & ) )(&XmlStorage_wrapper::default_Store)
            , ( bp::arg("storable") ) )    
        .def( 
            "UseIndentation"
            , (void ( ::CLAM::XmlStorage::* )( bool ) )( &::CLAM::XmlStorage::UseIndentation )
            , ( bp::arg("useIndentation") ) )    
        .def( 
            "WriteDocument"
            , (void ( ::CLAM::XmlStorage::* )( ::std::ostream & ) )( &::CLAM::XmlStorage::WriteDocument )
            , ( bp::arg("os") ) )    
        .def( 
            "WriteSelection"
            , (void ( ::CLAM::XmlStorage::* )( ::std::ostream & ) )( &::CLAM::XmlStorage::WriteSelection )
            , ( bp::arg("os") ) )    
        .staticmethod( "AppendToDocument" )    
        .staticmethod( "Dump" )    
        .staticmethod( "Restore" )    
        .staticmethod( "RestoreFromFragment" );

    { //::CLAM_20log10
    
        typedef float ( *CLAM_20log10_function_type )( float );
        
        bp::def( 
            "CLAM_20log10"
            , CLAM_20log10_function_type( &::CLAM_20log10 )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_atan
    
        typedef float ( *CLAM_atan_function_type )( float );
        
        bp::def( 
            "CLAM_atan"
            , CLAM_atan_function_type( &::CLAM_atan )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_atan2
    
        typedef float ( *CLAM_atan2_function_type )( float,float );
        
        bp::def( 
            "CLAM_atan2"
            , CLAM_atan2_function_type( &::CLAM_atan2 )
            , ( bp::arg("Imag"), bp::arg("Real") ) );
    
    }

    { //::CLAM_cos
    
        typedef float ( *CLAM_cos_function_type )( float );
        
        bp::def( 
            "CLAM_cos"
            , CLAM_cos_function_type( &::CLAM_cos )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_exp
    
        typedef float ( *CLAM_exp_function_type )( float );
        
        bp::def( 
            "CLAM_exp"
            , CLAM_exp_function_type( &::CLAM_exp )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_exp2
    
        typedef float ( *CLAM_exp2_function_type )( float );
        
        bp::def( 
            "CLAM_exp2"
            , CLAM_exp2_function_type( &::CLAM_exp2 )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_log
    
        typedef float ( *CLAM_log_function_type )( float );
        
        bp::def( 
            "CLAM_log"
            , CLAM_log_function_type( &::CLAM_log )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_log10
    
        typedef float ( *CLAM_log10_function_type )( float );
        
        bp::def( 
            "CLAM_log10"
            , CLAM_log10_function_type( &::CLAM_log10 )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_log2
    
        typedef float ( *CLAM_log2_function_type )( float );
        
        bp::def( 
            "CLAM_log2"
            , CLAM_log2_function_type( &::CLAM_log2 )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_pow
    
        typedef float ( *CLAM_pow_function_type )( float,float );
        
        bp::def( 
            "CLAM_pow"
            , CLAM_pow_function_type( &::CLAM_pow )
            , ( bp::arg("x"), bp::arg("y") ) );
    
    }

    { //::CLAM_sin
    
        typedef float ( *CLAM_sin_function_type )( float );
        
        bp::def( 
            "CLAM_sin"
            , CLAM_sin_function_type( &::CLAM_sin )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM_sqrt
    
        typedef float ( *CLAM_sqrt_function_type )( float );
        
        bp::def( 
            "CLAM_sqrt"
            , CLAM_sqrt_function_type( &::CLAM_sqrt )
            , ( bp::arg("x") ) );
    
    }

    { //::CLAM::ConnectControls
    
        typedef void ( *ConnectControls_function_type )( ::CLAM::Processing &,::std::string const &,::CLAM::Processing &,::std::string const & );
        
        bp::def( 
            "ConnectControls"
            , ConnectControls_function_type( &::CLAM::ConnectControls )
            , ( bp::arg("sender"), bp::arg("outControlName"), bp::arg("receiver"), bp::arg("inControlName") ) );
    
    }

    { //::CLAM::ConnectControls
    
        typedef void ( *ConnectControls_function_type )( ::CLAM::Processing &,unsigned int,::CLAM::Processing &,unsigned int );
        
        bp::def( 
            "ConnectControls"
            , ConnectControls_function_type( &::CLAM::ConnectControls )
            , ( bp::arg("sender"), bp::arg("outControlNumber"), bp::arg("receiver"), bp::arg("inControlNumber") ) );
    
    }

    { //::CLAM::ConnectPorts
    
        typedef void ( *ConnectPorts_function_type )( ::CLAM::Processing &,unsigned int,::CLAM::InPortBase & );
        
        bp::def( 
            "ConnectPorts"
            , ConnectPorts_function_type( &::CLAM::ConnectPorts )
            , ( bp::arg("sender"), bp::arg("outPortNumber"), bp::arg("receiver") ) );
    
    }

    { //::CLAM::ConnectPorts
    
        typedef void ( *ConnectPorts_function_type )( ::CLAM::OutPortBase &,::CLAM::Processing &,unsigned int );
        
        bp::def( 
            "ConnectPorts"
            , ConnectPorts_function_type( &::CLAM::ConnectPorts )
            , ( bp::arg("sender"), bp::arg("receiver"), bp::arg("inPortNumber") ) );
    
    }

    { //::CLAM::ConnectPorts
    
        typedef void ( *ConnectPorts_function_type )( ::CLAM::Processing &,unsigned int,::CLAM::Processing &,unsigned int );
        
        bp::def( 
            "ConnectPorts"
            , ConnectPorts_function_type( &::CLAM::ConnectPorts )
            , ( bp::arg("sender"), bp::arg("outPortNumber"), bp::arg("receiver"), bp::arg("inPortNumber") ) );
    
    }

    { //::CLAM::ConnectPorts
    
        typedef void ( *ConnectPorts_function_type )( ::CLAM::Processing &,::std::string const &,::CLAM::Processing &,::std::string const & );
        
        bp::def( 
            "ConnectPorts"
            , ConnectPorts_function_type( &::CLAM::ConnectPorts )
            , ( bp::arg("sender"), bp::arg("outPortName"), bp::arg("receiver"), bp::arg("inPortName") ) );
    
    }

    { //::CLAM::ConnectTypedControls
    
        typedef void ( *ConnectTypedControls_function_type )( ::CLAM::Processing &,::std::string const &,::CLAM::Processing &,::std::string const & );
        
        bp::def( 
            "ConnectTypedControls"
            , ConnectTypedControls_function_type( &::CLAM::ConnectTypedControls )
            , ( bp::arg("sender"), bp::arg("typedOutControlName"), bp::arg("receiver"), bp::arg("typedInControlName") ) );
    
    }

    { //::CLAM::ConnectTypedControls
    
        typedef void ( *ConnectTypedControls_function_type )( ::CLAM::Processing &,unsigned int,::CLAM::Processing &,unsigned int );
        
        bp::def( 
            "ConnectTypedControls"
            , ConnectTypedControls_function_type( &::CLAM::ConnectTypedControls )
            , ( bp::arg("sender"), bp::arg("typedOutControlNumber"), bp::arg("receiver"), bp::arg("typedInControlNumber") ) );
    
    }

    { //::CLAM::DB
    
        typedef double ( *DB_function_type )( double,int );
        
        bp::def( 
            "DB"
            , DB_function_type( &::CLAM::DB )
            , ( bp::arg("linData"), bp::arg("scaling")=(int)(20) ) );
    
    }

    { //::CLAM::GetFloatFromInControl
    
        typedef float ( *GetFloatFromInControl_function_type )( ::CLAM::Processing &,int );
        
        bp::def( 
            "GetFloatFromInControl"
            , GetFloatFromInControl_function_type( &::CLAM::GetFloatFromInControl )
            , ( bp::arg("proc"), bp::arg("inControlIndex") ) );
    
    }

    { //::CLAM::GetFloatFromInControl
    
        typedef float ( *GetFloatFromInControl_function_type )( ::CLAM::Processing &,::std::string const & );
        
        bp::def( 
            "GetFloatFromInControl"
            , GetFloatFromInControl_function_type( &::CLAM::GetFloatFromInControl )
            , ( bp::arg("proc"), bp::arg("inControlName") ) );
    
    }

    { //::CLAM::Lin
    
        typedef double ( *Lin_function_type )( double,int );
        
        bp::def( 
            "Lin"
            , Lin_function_type( &::CLAM::Lin )
            , ( bp::arg("logData"), bp::arg("scaling")=(int)(20) ) );
    
    }

    { //::CLAM::SendFloatToInControl
    
        typedef void ( *SendFloatToInControl_function_type )( ::CLAM::Processing &,int,float );
        
        bp::def( 
            "SendFloatToInControl"
            , SendFloatToInControl_function_type( &::CLAM::SendFloatToInControl )
            , ( bp::arg("receiver"), bp::arg("inControlIndex"), bp::arg("value") ) );
    
    }

    { //::CLAM::SendFloatToInControl
    
        typedef void ( *SendFloatToInControl_function_type )( ::CLAM::Processing &,::std::string const &,float );
        
        bp::def( 
            "SendFloatToInControl"
            , SendFloatToInControl_function_type( &::CLAM::SendFloatToInControl )
            , ( bp::arg("receiver"), bp::arg("inControlName"), bp::arg("value") ) );
    
    }

    { //::CLAM::SendFloatToOutControl
    
        typedef void ( *SendFloatToOutControl_function_type )( ::CLAM::Processing &,int,float );
        
        bp::def( 
            "SendFloatToOutControl"
            , SendFloatToOutControl_function_type( &::CLAM::SendFloatToOutControl )
            , ( bp::arg("sender"), bp::arg("inControlIndex"), bp::arg("value") ) );
    
    }

    { //::CLAM::SendFloatToOutControl
    
        typedef void ( *SendFloatToOutControl_function_type )( ::CLAM::Processing &,::std::string const &,float );
        
        bp::def( 
            "SendFloatToOutControl"
            , SendFloatToOutControl_function_type( &::CLAM::SendFloatToOutControl )
            , ( bp::arg("sender"), bp::arg("inControlName"), bp::arg("value") ) );
    
    }

    { //::isPowerOfTwo
    
        typedef bool ( *isPowerOfTwo_function_type )( ::CLAM::TUInt32 );
        
        bp::def( 
            "isPowerOfTwo"
            , isPowerOfTwo_function_type( &::isPowerOfTwo )
            , ( bp::arg("n") ) );
    
    }

    { //::log2lin
    
        typedef float ( *log2lin_function_type )( float );
        
        bp::def( 
            "log2lin"
            , log2lin_function_type( &::log2lin )
            , ( bp::arg("x") ) );
    
    }

    { //::nextPowerOfTwo
    
        typedef ::CLAM::TUInt32 ( *nextPowerOfTwo_function_type )( ::CLAM::TUInt32 );
        
        bp::def( 
            "nextPowerOfTwo"
            , nextPowerOfTwo_function_type( &::nextPowerOfTwo )
            , ( bp::arg("n") ) );
    
    }

    { //::Bindings::PyHacks::toComponent
    
        typedef ::CLAM::Component & ( *toComponent_function_type )( ::Bindings::Spectrum & );
        
        bp::def( 
            "toComponent"
            , toComponent_function_type( &::Bindings::PyHacks::toComponent )
            , ( bp::arg("s") )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::Bindings::PyHacks::toComponent
    
        typedef ::CLAM::Component & ( *toComponent_function_type )( ::CLAM::Network & );
        
        bp::def( 
            "toComponent"
            , toComponent_function_type( &::Bindings::PyHacks::toComponent )
            , ( bp::arg("n") )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::Bindings::PyHacks::toComponent
    
        typedef ::CLAM::Component & ( *toComponent_function_type )( ::CLAM::ProcessingData & );
        
        bp::def( 
            "toComponent"
            , toComponent_function_type( &::Bindings::PyHacks::toComponent )
            , ( bp::arg("pd") )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    bp::scope().attr("FLOAT_OFFSET") = FLOAT_OFFSET;

    bp::scope().attr("HUGE_") = HUGE_;

    bp::scope().attr("LN10") = LN10;

    bp::scope().attr("LN2") = LN2;

    bp::scope().attr("LN2_OVER_LN10") = LN2_OVER_LN10;

    bp::scope().attr("LONG_OFFSET") = LONG_OFFSET;

    bp::scope().attr("ONE_OVER_LN10") = ONE_OVER_LN10;

    bp::scope().attr("ONE_OVER_LN2") = ONE_OVER_LN2;

    bp::scope().attr("ONE_OVER_PI") = ONE_OVER_PI;

    bp::scope().attr("ONE_OVER_TWOPI") = ONE_OVER_TWOPI;

    bp::scope().attr("PI_") = PI_;

    bp::scope().attr("PI_2") = PI_2;

    bp::scope().attr("ROOT2") = ROOT2;

    bp::scope().attr("TIMES20LN2_OVER_LN10") = TIMES20LN2_OVER_LN10;

    bp::scope().attr("TWOPI") = TWOPI;

    bp::scope().attr("TWO_OVER_PI") = TWO_OVER_PI;
}
