AC_LANG_CPLUSPLUS()

AC_MSG_CHECKING([default g++ compiler])
CXXVERSION=`g++ -v 2>&1 | grep 'gcc version' | sed -e 's/.*gcc version \([[^ ]]*\).*/\1/'`
AC_MSG_RESULT($CXXVERSION)
CXXVERSION_MAJOR=`echo $CXXVERSION | cut -d'.' -f1`
CXXVERSION_MINOR=`echo $CXXVERSION | cut -d'.' -f2`
AC_MSG_CHECKING([if default g++ compiler is acceptable])
if test $CXXVERSION_MAJOR = 3
then
	CXX=g++
	AC_MSG_RESULT([yes: $CXX version is $CXXVERSION])
else
	if test $CXXVERSION_MAJOR = 2
	then
		if test $CXXVERSION_MINOR = 96
		then
			AC_MSG_RESULT([no: $CXX version is $CXXVERSION])
			AC_MSG_CHECKING([if prefered g++3 is available])
			if test x`which g++3` != x
			then
				CXX=g++3
				CXXVERSION=`g++3 -v 2>&1 | grep 'gcc version' | sed -e 's/.*gcc version \([[^ ]]*\).*/\1/'`
				AC_MSG_RESULT([yes: $CXX version is $CXXVERSION])
			else
				if test x`which g++-3.0` != x
				then
					CXX=g++-3.0
					CXXVERSION=`$CXX -v 2>&1 | grep version | cut -d' ' -f3`
					AC_MSG_RESULT([yes: $CXX version is $CXXVERSION])
				fi			
			fi
		else
			AC_MSG_RESULT([yes: $CXX version is $CXXVERSION])
		fi
	else
		AC_MSG_ERROR([cannot handle g++ version $CXXVERSION]);
	fi
fi


AC_MSG_CHECKING([for wchar_t support in libstdc++])
AC_TRY_LINK([
#include <string>
],
[
	const wchar_t str[] = {0xFABB,0x0000,0x12FF,0x33FF};
	std::basic_string<wchar_t> theString;
	theString.assign( (wchar_t*)str, 2);      

	return 0;
],[UNICODE_SUPPORT_AVAILABLE="yes"],[UNICODE_SUPPORT_AVAILABLE="no"])

if test $UNICODE_SUPPORT_AVAILABLE = "yes"
then
	DEFINE_HAVE_STANDARD_UNICODE="HAVE_STANDARD_UNICODE"
	AC_MSG_RESULT(yes)
else
	AC_MSG_RESULT(no)
fi


dnl Try the vector::at method.
AC_MSG_CHECKING([for std::vector::at() method in libstdc++])
AC_TRY_RUN([
#include<vector>
int main() {
	std::vector<int> v(1);
	v[0]=0;
	return v.at(0);
}
],[vec_at_fails=no],[vec_at_fails=yes],[echo $ac_n "cross compiling; assumed OK... $ac_c"])

if test x$vec_at_fails = xno
then
	AC_MSG_RESULT(yes)
	DEFINE_HAVE_STANDARD_VECTOR_AT=HAVE_STANDARD_VECTOR_AT
else
	AC_MSG_RESULT(no)
fi

dnl We now try to make the standard sstream header work
	dnl Really old versions of g++ do not have it.
AC_MSG_CHECKING([for standard sstream header in libstdc++])
AC_TRY_RUN([
#include<sstream>
int main() {
	std::stringstream ss;
	ss << "hi!" << std::ends;
	return 0;
}
],[sstream_fails=no],[sstream_fails=yes],
[echo $ac_n "cross compiling; assumed OK... $ac_c"]
)

if test x$sstream_fails = xno
then
	AC_MSG_RESULT([yes])
	DEFINE_HAVE_STANDARD_SSTREAM=HAVE_STANDARD_SSTREAM
	DEFINE_HAVE_STANDARD_SSTREAM_STR=HAVE_STANDARD_SSTREAM_STR
else
	AC_MSG_RESULT(no)
	dnl We don't have the standard, so we check if older headers are provided
	AC_MSG_CHECKING([for obsolete strstream header in libstdc++])
	AC_TRY_RUN([
#include<strstream>
int main() {
	std::strstream ss;
	ss << "hi!" << std::ends;
}
],[strstream_fails=no],[strstream_fails=yes],
[echo $ac_n "cross compiling; assumed OK... $ac_c"])

	if test "$strstream_fails" = no
	then
		AC_MSG_RESULT([yes])
		DEFINE_HAVE_STRSTREAM_SSTREAM=HAVE_STRSTREAM_SSTREAM
		dnl Bad luck. No known string stream header file found.
	else
		AC_MSG_ERROR(
[No standard c++ library String Streams header file found!]
		)
	fi
fi


dnl It seems we have an old string stream implementation. Lets check
dnl if it has any peculiarity...
AC_MSG_CHECKING([if stringstream::str() returns std::string in libstdc++])
AC_TRY_RUN([
#ifdef STANDARD_SSTREAM
#include <sstream>
#else
#include <strstream>
#endif
#include<iostream>
int main() {
	#ifdef STANDARD_SSTREAM
	std::stringstream ss("hi");
	#else
	std::strstream ss;
	ss << "hi";
	#endif
	if ( ss.str().c_str()[0] == 'h') return 0;
	return 1;
}
],[str_string_fails=no],[str_string_fails=yes],
[echo $ac_n "cross compiling; assumed OK... $ac_c"]
)

if test x$str_string_fails = xno
then
	AC_MSG_RESULT(yes)
	DEFINE_HAVE_STANDARD_SSTREAM_STR=HAVE_STANDARD_SSTREAM_STR
else
	AC_MSG_RESULT(no)
fi


AC_SUBST(DEFINE_HAVE_STANDARD_SSTREAM_STR)
AC_SUBST(DEFINE_HAVE_STANDARD_SSTREAM)
AC_SUBST(DEFINE_HAVE_STANDARD_UNICODE)

