# Created by Martin Ecker, April 2002
# messed by Miguel Ramirez, November 2002

# Create a Makefile in the folder of your program and
# then define a variable named program_name with the name
# of the sample as well as a variable UNIX_TOOLS pointing to the
# directory unix_tools of your project file ( this one for your convenience )
#
# Then define the following variables (don't forget to define VPATH as necessary!):
# sourcefiles ... the .cpp, .cxx files of your program
# headerfiles ... the .h, .hxx files of your library
# inlinefiles ... the .inl files of your library
# objectfiles ... the .o files of your library WITHOUT any prefixed path, just name.o for all files
#
# You should also define the following variables
# targetdir_release ... the relative path to the place you want the release binaries to be put
# targetdir_debug   ... the relative path to etc.
# objdir_release    ... the place where you want to put the release binaries
# objdir_debug      ... the place where you want to put the debug   binaries
#
# Additionally, you may also define
# either include the make.default file at $(UNIX_TOOLS)
# or redefine the variables found there.
#
# Finally, include this file into your makefile and
# you can build a debug version by using 'make debug'
# or a release version by using 'make release'
# 'make all' or simply 'make' creates both targets.
# 'make clean' deletes all intermediate and output files.

CFLAGS_release = -Wall -O2
CFLAGS_debug = -Wall -g
CPPFLAGS_release = $(defines_release) $(includedirs)
CPPFLAGS_debug = $(defines_debug) $(includedirs)
LDFLAGS_release = $(libdirs) $(libs_release)
LDFLAGS_debug = $(libdirs) $(libs_debug)

CC = gcc
CXX = g++
LINK = g++ -o
MKDIR = mkdir -p


target_release = $(targetdir_release)/$(program_name)
target_debug = $(targetdir_debug)/$(program_name)

# get the dependency file names
dependfiles = $(patsubst %.o,%.d,$(objectfiles))


# implicit rule to compile .cpp files using the C++ compiler
$(objdir_release)/%.o: %.cpp
	@echo Compiling $<
	$(CXX) -c $< $(CPPFLAGS_release) $(CFLAGS_release) -o $@
$(objdir_debug)/%.o: %.cpp
	@echo Compiling $<
	$(CXX) -c $< $(CPPFLAGS_debug) $(CFLAGS_debug) -o $@

#implicit rule to compile .cxx files using C++ compiler
$(objdir_release)/%.o: %.cxx
	@echo Compiling $<
	$(CXX) -c $< $(CPPFLAGS_release) $(CFLAGS_release) -o $@
$(objdir_debug)/%.o: %.cxx
	@echo Compiling $<
	$(CXX) -c $< $(CPPFLAGS_debug) $(CFLAGS_debug) -o $@

#implicit rule to compile .c files using C compiler
$(objdir_release)/%.o: %.c
	@echo Compiling $<
	$(CC) -c $< $(CPPFLAGS_release) $(CFLAGS_release) -o $@
$(objdir_debug)/%.o: %.c
	@echo Compiling $<
	$(CC) -c $< $(CPPFLAGS_debug) $(CFLAGS_debug) -o $@


# implicit rule to generate dependency files for all .cpp files
# the first sed adds the .d file as target, so it changes the compiler output
# from "foo.o: foo.cpp foo.h" to "foo.o $(objdir)/foo.d : foo.cpp foo.h"
# and the second sed replaces "foo.o" with "$(objdir)/foo.o"
$(objdir_release)/%.d: %.cpp
	@-$(MKDIR) $(objdir_release)
	@$(SHELL) -ec '$(CXX) -M $(CPPFLAGS_release) $(CFLAGS_release) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_release)/$*)\\.o /g" > $@'
$(objdir_debug)/%.d: %.cpp
	@-$(MKDIR) $(objdir_debug)
	@$(SHELL) -ec '$(CXX) -M $(CPPFLAGS_debug) $(CFLAGS_debug) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_debug)/$*)\\.o /g" > $@'

$(objdir_release)/%.d: %.cxx
	@-$(MKDIR) $(objdir_release)
	@$(SHELL) -ec '$(CXX) -M $(CPPFLAGS_release) $(CFLAGS_release) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_release)/$*)\\.o /g" > $@'
$(objdir_debug)/%.d: %.cxx
	@-$(MKDIR) $(objdir_debug)
	@$(SHELL) -ec '$(CXX) -M $(CPPFLAGS_debug) $(CFLAGS_debug) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_debug)/$*)\\.o /g" > $@'

$(objdir_release)/%.d: %.c
	@-$(MKDIR) $(objdir_release)
	@$(SHELL) -ec '$(CC) -M $(CPPFLAGS_release) $(CFLAGS_release) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_release)/$*)\\.o /g" > $@'
$(objdir_debug)/%.d: %.c
	@-$(MKDIR) $(objdir_debug)
	@$(SHELL) -ec '$(CC) -M $(CPPFLAGS_debug) $(CFLAGS_debug) $< | sed "s/$*\\.o/& $(subst /,\/,$@) /g" | sed "s/$*\\.o/$(subst /,\/,$(objdir_debug)/$*)\\.o /g" > $@'


# builds all targets
.PHONY: all
all: release debug

# builds the release version of the library
.PHONY: release create_release_dirs
release: create_release_dirs $(target_release)
create_release_dirs:
	@echo Building release version of $(program_name)
	@-$(MKDIR) $(targetdir_release)
	@-$(MKDIR) $(objdir_release)
$(target_release): $(addprefix $(objdir_release)/,$(objectfiles))
	@echo Linking $(target_release)...
	$(LINK) $(target_release) $(addprefix $(objdir_release)/,$(objectfiles)) $(LDFLAGS_release)

# builds the debug version of the library
.PHONY: debug create_debug_dirs
debug: create_debug_dirs $(target_debug)
create_debug_dirs:
	@echo Building debug version of $(program_name)
	@-$(MKDIR) $(targetdir_debug)
	@-$(MKDIR) $(objdir_debug)
$(target_debug): $(addprefix $(objdir_debug)/,$(objectfiles))
	@echo Linking $(target_debug)...
	$(LINK) $(target_debug) $(addprefix $(objdir_debug)/,$(objectfiles)) $(LDFLAGS_debug)

# include dependency files for all the object files, in case they don't yet exist we add
# - in front of the include to ignore any file not found errors we get
-include $(addprefix $(objdir_release)/,$(dependfiles))
-include $(addprefix $(objdir_debug)/,$(dependfiles))

# cleans all release intermediate and output files
.PHONY: clean_release
clean_release:
	@echo Removing all intermediate and output files for release build
	@-rm -f $(objdir_release)/*
	@-rm -f $(target_release)

# cleans all debug intermediate and output files
.PHONY: clean_debug
clean_debug:
	@echo Removing all intermediate and output files for debug build
	@-rm -f $(objdir_debug)/*
	@-rm -f $(target_debug)

# cleans all intermediate and output files
.PHONY: clean
clean: clean_release clean_debug










