<HTML><HEAD>
<TITLE>dir_it.3</TITLE>
</HEAD>
<BODY BGCOLOR=white LINK="0000FF" VLINK="800080">
<IMG SRC=c++boost.jpg ALIGN=TOP WIDTH=277 HEIGHT=86><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 COLS=2>
<TR><TD WIDTH=109 VALIGN=TOP><IMG SRC=sidebar.jpg WIDTH=109 HEIGHT=494>
</TD><TD>
<FONT FACE="Arial"><FONT SIZE=3>
<SPACER TYPE=VERTICAL SIZE=40>
<H1>dir_it</H1>
<H2>iterator to get all files in a directory</H2>
<H1>Abstract</H1>

The Standard C++ Library does not have any way to access
the directory structure of a computer. This is due to the
missing notion of directories at all on some C++ target
platforms. However, many important platforms do have a notion of
a directory but the system interface is very different between
these platforms. This class provides a standard interface which
is extensible to suit specific needs on the platform (when it
comes to the need to access file attributes).


  <A NAME="Synopsis"><H1>Synopsis</H1></A>

    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 COLS=2>
<TR><TD WIDTH=30 VALIGN=TOP></TD><TD>
<PRE>
#include &lt;boost/directory.h&gt;

std::string dirname(...);

boost::filesystem::dir_it begin(dirname);
boost::filesystem::dir_it end;
boost::filesystem::dir_it it(begin);

it = begin
*it
++it
*it++
it == end
it != end

prop::value_type v = boost::filesystem::get&lt;prop&gt;(it)
boost::filesystem::set&lt;prop&gt;(it, value)
    </PRE></TD></TABLE>

  
  <A NAME="Description"><H1>Description</H1></A>

    The class <TT>boost::filesystem::dir_it</TT> (<TT>dir_it</TT> for short)
    is an input iterator which iterates over the entries in a directory.
    A begin iterator is constructed from a valid directory name using the
    platform specific notation, an end
    iterator is constructed using the default constructor of the class.
    The two function <TT>boost::filesystem::get()</TT> and
    <TT>boost::filesystem::set()</TT> are used to access specific properties
    of a file. The exact list of available properties depends on the
    system. Below is a list of common properties and lists of properties
    supported on specific systems.

    <P>


    Since the file properties differ between systems, an extensible
    interface was choosen to allow different sets of properties to be
    accessed. It is even possible for the user to add special properties.
    To define a new file property, a <TT>struct</TT> is defines which
    gives the name and the type to the property. Of course, it is also
    necessary to define the <TT>get()</TT> and/or <TT>set()</TT> functions.
    Details for this are given below.
  
  <A NAME="Basic Functionality"><H1>Basic Functionality</H1></A>

    The main functionality of the class <TT>dir_it</TT> is to iterate
    over the entries in a directory. Here is an example how the class
    can be used to print the files in a directory:
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 COLS=2>
<TR><TD WIDTH=30 VALIGN=TOP></TD><TD>
<PRE>
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;boost/directory.h&gt;

int main(int ac, char *av[])
{
  if (ac == 2)
  {
    typedef boost::filesystem::dir_it        InIt;
    typedef std::ostream_iterator&lt;std::string&gt; OutIt;

    std::copy(InIt(av[1]), InIt(), OutIt(std::cout, "\\n"));
  }
  return 0;
}
    </PRE></TD></TABLE>

    <P>

    Of course, it is also possible to do this loop manually: The
    class <TT>dir_it</TT> is just an input iterator. Note, that
    the post increment operator only returns a proxy object which
    can be used for dereferencing (using <TT>operator*()</TT>) as
    required by the input iterator specification. However, the
    proxy object cannot be used to access other file attributes
    than the name.
  
  <A NAME="dir_it Members"><H1>dir_it Members</H1></A>

    <A NAME="Lifecycle"><H3>Lifecycle</H3></A>

      <DL>
<DT>
Default Constructor
<DD>

          The default constructor is used to create the "past the
          end" iterator. This construction never fails and the
          resulting iterator cannot be deferenced.
        
<DT>
Constructor taking a std::string
<DD>

          A <TT>std::string</TT> naming a directory can be used to
          construct a "begin" iterator. If the argument does
          not name an accessible directory, the resulting iterator
          compares equal to the past the end iterator constructed
          with the default constructor. On most system it is no
          problem how this failure is indicated because even an
          empty directory has entries, e.g. on POSIX systems the
          directories "." (the directory itself) and ".."
          (the parent directory).
        
<DT>
Copy Constructor
<DD>

          The copy constructor creates a new instance which is
          always positioned on the same current entry as the
          original <TT>dir_it</TT> instance. This means, that
          advancing either the original or the newly created
          iterator will advance both iterators. It is not
          possible to copy a <TT>dir_it</TT> to iterate over the
          same directory entries twice. To do this, two objects
          of type <TT>dir_it</TT> have to be constructed from the
          directory name.
        
<DT>
Destructor
<DD>

          The destructor releases the resources associated with
          the <TT>dir_it</TT>. However, if the <TT>dir_it</TT> was
          copied, associated system resources are released when
          the last copy is destroyed. This is because the various
          copies share the same system resources.
        
<DT>
Assignment
<DD>

          The assigned <TT>dir_it</TT> is always position on the
          same entry as the original iterator. Thus, the same
          restriction on the assigned iterator apply as
          those for iterators created with the copy constructor.
        
</DL>

    
    <A NAME="Operations"><H3>Operations</H3></A>

      <DL>
<DT>
Dereference (<TT>operator*()</TT>)
<DD>

          Dereferencing a <TT>dir_it</TT> returns the name of the
          current directory entry as <TT>std::string</TT>. It is
          only possible to derference a <TT>dir_it</TT> if it does
          not compare equal to the past the end iterator.
        
<DT>
Pre Increment (<TT>operator++()</TT>)
<DD>

          The major means to advance a <TT>dir_it</TT> is the pre
          increment operator. This operation moves the object to
          the next directory entry, if there is another entry.
          Otherwise, the <TT>dir_it</TT> object compares equal to
          the past the end iterator after the pre increment. The
          pre increment operator returns the object itself.
        
<DT>
Post Increment (<TT>operator++(int)</TT>)
<DD>

          The post increment advances the <TT>dir_it</TT> to the
          next entry and returns a proxy object which can be
          dereferenced as if it were an object of type
          <TT>dir_it</TT>. However, nothing else can be done with
          this object. This method of advancing the iterator is
          normally less efficient such that the pre increment
          operator should be used if possible.
        
<DT>
Equals Operator (<TT>operator==()</TT>)
<DD>

          The equals operator determines whether two objects of
          type <TT>dir_it</TT> are either both indicating a
          current directory entry, or both objects are past
          the end iterators. Because every directory turns into
          a past the end iterator once all entries in the
          directory have been seen, this can be used to test
          whether there are any more entries. However, it is
          not possible to determine whether a <TT>dir_it</TT> is
          positioned on a specific directory entry (but this
          can be done by comparing the results of the
          dereference operator).
        
<DT>
Not Equal Operator (<TT>operator!=()</TT>)
<DD>

          The not equal operator returns the exact negation of the
          equals operator. Thus, this operator returns <TT>true</TT>
          if one of the two iterators indicates a current
          directory entry while the other iterator is a past the
          end iterator.
        
</DL>
 
    
  
  <A NAME="File Properties"><H1>File Properties</H1></A>

    Using the functions <TT>get()</TT> and <TT>set()</TT> it is
    possible to access file properties. Here is an example
    which prints the file sizes in addition to the name:
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 COLS=2>
<TR><TD WIDTH=30 VALIGN=TOP></TD><TD>
<PRE>
#include &lt;iostream&gt;
#include &lt;boost/directory.h&gt;

int main(int ac, char *av[])
{
  if (ac == 2)
  {
    using namespace boost::filesystem;

    for (dir_it it(av[1]); it != dir_it(); ++it)
      std::cout &lt;&lt; std::setw(10) &lt;&lt; get&lt;size&gt;(it)
                &lt;&lt; " " &lt;&lt; *it &lt;&lt; "\\n";
  }
  return 0;
}
    </PRE></TD></TABLE>

    <P>

    Each property constists of two major components
    <UL>
<LI>

      A <TT>struct</TT> which gives the name to the
      property and which defines the type accessed
      using the property. The type of the property is
      defined using a <TT>typedef</TT> defining the type
      <TT>value_type</TT> in the corresponding
      <TT>struct</TT>. For the standard properties,
      the corresponding <TT>struct</TT>s are defined
      in the namespace <TT>boost::filesystem</TT>.
    
<LI>

      Access functions which are just specializations
      of the functions <TT>boost::filesystem::get()</TT>
      and <TT>boost::filesystem::set()</TT>. Of course,
      if the property can only be read or only be
      written, only the corresponding access function is
      defined.
    
</UL>

    <A NAME="Example Property"><H3>Example Property</H3></A>

      The <TT>size</TT> property used in the
      above example might be defined as follows:
      <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 COLS=2>
<TR><TD WIDTH=30 VALIGN=TOP></TD><TD>
<PRE>
namespace boost {
  namespace filesystem {
    struct size
    {
      typedef size_t value_type;
    };

    template &lt;&gt;
    size::value_type get&lt;size&gt;(dir_it const &it)
    {
      return ... /* environment specific code */
    }
  }
}
      </PRE></TD></TABLE>

      <P>

      The properties which are already provided by the
      implementation normally access some data structure
      internal to the <TT>dir_it</TT> objects to avoid
      multiple system calls.
    
		<A NAME="Details"><H3>Details</H3></A>

      <DL>
<DT>
Property Selection
<DD>

          The file property to be accessed is selected
          using a template argument to the <TT>get()</TT> or
          <TT>set()</TT> function. The template argument is
          a type which defines the type <TT>value_type</TT>
          as a subtype. The <TT>get()</TT> and <TT>set()</TT>
          functions are specialized for the properties
          provided by the system. By specializing addtional
          versions of these functions, the user may extend
          the set of accessible properties.
        
<DT>
Property Type
<DD>

          The type of a file property is determined from
          a <TT>typedef</TT> called <TT>value_type</TT> in
          the type selecting the property.
        
<DT>
Reading a Property
<DD>

          To read a file property, a <TT>dir_it</TT> is
          passed as argument to the template function
          <TT>boost::filesystem::get()</TT>. The
          template argument <TT>prop</TT> selecting the file
          property to be accessed is explicitly specified.
          The return type returned from the <TT>get()</TT>
          function is <TT>prop::value_type</TT>.
        
<DT>
Setting a Property
<DD>

          To set a file property, a <TT>dir_it</TT> and the
          new value of the property are passed to the
          template function <TT>boost::filesystem::set()</TT>.
          The template argument <TT>prop</TT> selecting the
          file property to be accessed is explicitly specified.
          The type of the second argument to the <TT>set()</TT>
          function is <TT>prop::value_type const &</TT>.
        
</DL>

    
    <A NAME="Standard Properties"><H3>Standard Properties</H3></A>

      The organization of files differ heavily between
      different system. As a result, the sets of file
      properties defined on different systems vary. The
      property interface is choosen such that it is
      obvious how specific properties are accessed except
      that the names and the exact types are still open. To
      enhance portability, some common file properties are
      always defined:
      <DL>
<DT>
is_directory
<DD>

          A boolean read only property which can be used to
          determine whether a directory entry is itself a
          directory.
        
<DT>
is_hidden
<DD>

          A boolean property indicating whether the file is
          "hidden". By default, hidden files are not shown
          to the user. However, with appropriate options,
          these files may be shown anyway. On some systems,
          there is a special flag for the files which indicates
          that the file is hidden. On such systems this flag
          is a read/write property. On other systems, e.g. on
          POSIX systems, files starting with a dot (".") are
          considered to be hidden. On such systems this flag
          is a read only property.
        
<DT>
size
<DD>

          A read only property of type <TT>size_t</TT> returning
          the size in bytes of a file. Note that the size
          returned is not necessarily identical to the number
          of characters retrieved from an <TT>ifstream</TT>
          created for this file: In text mode, some character
          sequences are replaced by single characters during
          reading. However, the number of characters in binary
          mode should normally match the size of the file.
        
<DT>
mtime
<DD>

          A read only property of type <TT>time_t</TT> returning
          the last modification time of the file. On some
          systems, e.g. POSIX, it is possible to write this
          property to set the value to an arbitrary value.
        
</DL>

    
    <A NAME="POSIX Properties"><H3>POSIX Properties</H3></A>

    
    <A NAME="WinNT Properties"><H3>WinNT Properties</H3></A>

    
  
  <A NAME="Future Directions"><H1>Future Directions</H1></A>

    In computer systems there are other structures than the
    system's directory which can also be viewed as directories.
    An obvious example are archive files which store copies
    of directory hierarchies, like ZIP or tar files. It might
    be useful to extend the class <TT>dir_it</TT> to consider
    such structures also to be directories and somehow add
    support to iterate of these.

    <P>


    A potential approach might be the definition of a CORBA
    interface which is used internally by the class
    <TT>dir_it</TT> to determine directory entries and to
    figure out, whether an entry itself a directory. This
    way it would be possible to even extend what is considered
    to be a directory and have the same class iterate over
    very different structures.
   
    <P>


    Whether this approach is reasonable whill have to be
    evaluated in the future. Personally, I think this is
    an interesting direction and I hope that I will find
    time to test this in the near future.
  
  <A NAME="See Also"><H1>See Also</H1></A>

    POSIX: opendir(3), readdir(3), closedir(3), stat(2)
    <BR>

    Standard Template Library: Input Iterator Requirements
  
<HR>

<A HREF=http://www.claas-solutions.de/~kuehl>Dietmar K&uuml;hl</A> &lt;dietmar.kuehl@claas-solutions.de&gt;<BR>
</FONT></FONT>
</TD></TR></TABLE>
</BODY></HTML>

