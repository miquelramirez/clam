- Dummy Network:
[X]	- processingsName -> processingNames
	- Dummy: tests for ProcessingWithConfig
	- _dummyPrototypes: when two or more processings of the same type are added, changes to one affect the others


- Polishing connector interface:
	- Dummy_NetworkProxy.connectorType,Index... failure case (assert? exception?)
[X]	- Index and type should be queried to the proxy instead of passed as constructor parameters and stored as attribute. 
		For tests using constructor parameters instead of a definition structure we can keep these attributes, query the proxy just when they are None
	- PeerConnectors.__len__()
[X]	- Rework proxy interface and external objects constructors so that parameters are specified in order of search
		(proxy,processingname,kind,direction,connectorname...)

- Network interface:
	- Given a dummy defined network net=Network(dummyProxy)
[X]		- Getting a processing with net.procesingName
[X]		- Getting a processing with net["processingName"]
[X]		- Failure case on net.missingProcessingName 
[X]		- Failure case on net["missingProcessingName"]
[X]		- Exploring the processings in a network with net.[tab] (__dir__)
[X]		- In parallel defining and refactor dummy proxy interface for processing enumeration
	- Creating processings
[X]		- Processing factories for the dummy proxy
[X]		- Adding a processing
[X]			- 1 x Network.addProcessing -> code
[X]			- 2 x Network.addProcessing -> code (same type)
[X]			- 2 x Network.addProcessing (different type) -> code
	- Self generation code (network is able to generate python code to generate itself again)
[X]		- Self writting code for processings
[X]		- Self writting code for connections
		- Self writting code for configurations
	- Dummy Configurations
		- Config information in dummy proxy (tests)
		- config = proc.config.clone()
		- proc.config = config
		- proc.config.Param1 = "illegal value" -> raise
			- ask proxy.isCompatibleConfigurationValue(proc, param, value)
		- proc.config.Param1 = "value"
			- config = proxy.setConfiguration(proc)
			- config.setValue(param, value)
			- proxy.Configure(proc, config)
	- CLAM Configurations
		- Implement the visitor
			- from a CLAM::Configuration get a proper ipyclam::Configuration
			- from a ipyclam::Configuration obtain a CLAM::Configuration
	- Multilevel configs
	- Additional features
[X]		- dir(network.types) should give all the available types as symbols
[X]		- network.types.MinimalProcessing should return "MinimalProcessing"
[X]		- network.types.NonExistingType should raise AttributeError
[X]		- network.processing1.name = processing2 # renaming
		- network.processing1 = network.processing2 # cloning
[X]		- network.description
[X]		- network.description = "A description"
		- del network.processing1 # removing
[X]		- network.processing1.InControl1.disconnect(network.Processing1.OutControl1) # just that connection
			- Fail if not connected?
[X]		- network.processing1.InControl1.disconnect(network.Processing1) # any connections to Processing1
[X]		- network.processing1.InControl1.disconnect() # any connections
		- network.code = "Type", should fail (and any existing network method)
[X]		- net.code(networkVar="aNetwork") generates code using 'aNetwork' as var for the network
		- net.code dealing weird names, should use subscript net["A processing"] or net.proc1["A connector"]
			- Failing names:
				- Containing other than [a-zA-Z_][a-zAz_09]*
				- Names which are properties (types, 
			- When?
				- Processing instantiation
				- Procesing in processing connection
				- Connector in processing connector
			- How?
				- helper function appendAttribute(name) which returns "."+name if ok or "['%s']"%name if not ok
				- helper function isAlphanumeric(name) which returns 
				- helper to know whether is a given property of the entity (how??)
		- Broadcast/Bus connections: 
			- Behaviour:
				- return the number of connections done
				- connect as many compatible connections as available, matching index
				- < and > version restrict directionality
			- Connectors.connect(Connector): all from Connectors connectable to Connector (returns n of connections done)
			- Connector.connect(Connectors): all from Connector connectable to Connectors (returns n of connections done)
			- Processing.connect(Connector): all from processing connectable to Connector
			- Processing.connect(Connectors): all from processing connectable to Connectors
			- Processing.connect(Processing): all connectable in order
			- Connector.connect(Processing): all from processing connectable to Connector
			- Connectors.connect(Processing): all from processing connectable to Connector
			- Connectors[1::2].connect(Processing) and the like (Suggestion the slice should return a Connectors with a diferent list)
	- Advanced features (no prioritary at all)
		- Type properties (category, description, port_monitor_type, icon, faust_svg...)
			- net.types.AType should be able to be used as now to instanciate processings
			- They are dynamic properties that may or may not be present
			- They are not settable
			- Now types are strings, after this feature current code should still work
		- Type categories: there are many types, we have categories, solutions?
			- net.types.categories.[tab]


- Connecting
	- Test Connector.connect(Connector)
[X]		increments the peers
[X]		increments the peer peers
		many kinds:
[X]			output first
[X]			input first
[X]			controls
[X]			ports
		error conditions
[X]			different kind
[X]			same direction
[X]			different type
[X]	- Test > operator to connect
[X]	- Test < operator to connect


- Bugs
[X]	- Network.__dir__ should return also types
[X]	- Do not allow repeated connections
[X]	- > and < operators should ensure direction matches with arrows
